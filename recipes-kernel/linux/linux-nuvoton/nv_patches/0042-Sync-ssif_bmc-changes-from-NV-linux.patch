From 17680509f2423dd04782a2686e8c423d8f941ca8 Mon Sep 17 00:00:00 2001
From: Marvin Lin <milkfafa@gmail.com>
Date: Fri, 19 Dec 2025 11:39:40 +0800
Subject: [PATCH] Sync ssif_bmc changes from NV linux 6.12

Upstream-Status: Pending [Not submitted to upstream yet]
---
 drivers/char/ipmi/Kconfig          |   4 +
 drivers/char/ipmi/ssif_bmc.c       | 594 +++++++++++++++++++----------
 include/uapi/linux/ipmi_ssif_bmc.h |   7 +-
 3 files changed, 407 insertions(+), 198 deletions(-)

diff --git a/drivers/char/ipmi/Kconfig b/drivers/char/ipmi/Kconfig
index fcb41daa43f5..9b8cfb7fcc8f 100644
--- a/drivers/char/ipmi/Kconfig
+++ b/drivers/char/ipmi/Kconfig
@@ -207,6 +207,10 @@ config SSIF_IPMI_BMC
 	  The driver implements the BMC side of the SMBus system
 	  interface (SSIF).
 
+config SEPARATE_SSIF_POSTCODES
+	bool "Separate ipmi post codes writes to another channel"
+	depends on SSIF_IPMI_BMC
+
 config IPMB_DEVICE_INTERFACE
 	tristate 'IPMB Interface handler'
 	depends on I2C
diff --git a/drivers/char/ipmi/ssif_bmc.c b/drivers/char/ipmi/ssif_bmc.c
index bc16f4697e74..7d859e238e6f 100644
--- a/drivers/char/ipmi/ssif_bmc.c
+++ b/drivers/char/ipmi/ssif_bmc.c
@@ -6,7 +6,6 @@
  *
  */
 
-#include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/miscdevice.h>
 #include <linux/module.h>
@@ -19,10 +18,21 @@
 #include <linux/timer.h>
 #include <linux/jiffies.h>
 #include <linux/ipmi_ssif_bmc.h>
+#include <linux/kfifo.h>
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+
+#include <linux/device.h>
+#include <linux/aspeed-2600-ara.h>
+#include <linux/i2c-aspeed.h>
 
 #define DEVICE_NAME                             "ipmi-ssif-host"
-#define SSIF_BMC_BUSY   0
-#define SSIF_BMC_READY  1
+#ifdef CONFIG_SEPARATE_SSIF_POSTCODES
+#define DEVICE_NAME_POST                        "ipmi-ssif-postcodes"
+#define POST_CODE_SIZE 9
+#define POST_CODE_OFFSET 3
+#endif //CONFIG_SEPARATE_SSIF_POSTCODES
+
 #define GET_8BIT_ADDR(addr_7bit)                (((addr_7bit) << 1) & 0xff)
 
 /* A standard SMBus Transaction is limited to 32 data bytes */
@@ -41,8 +51,13 @@
 #define SSIF_IPMI_MULTIPART_READ_START          0x3
 #define SSIF_IPMI_MULTIPART_READ_MIDDLE         0x9
 
-/* Max timeout is 15 seconds */
-#define RESPONSE_TIMEOUT                        15000 /*ms*/
+#define BUFFER_SIZE 1024
+
+#ifdef CONFIG_I2C_ASPEED
+#define I2C_SLAVE_ADDR_REG ASPEED_I2C_DEV_ADDR_REG
+#else
+#define I2C_SLAVE_ADDR_REG 0x40
+#endif
 
 struct ssif_part_buffer {
 	u8 address;
@@ -78,13 +93,13 @@ struct ssif_bmc_ctx {
 	int                     msg_idx;
 	bool                    pec_support;
 	/* ssif bmc spinlock */
-	spinlock_t              lock;
-	wait_queue_head_t       wait_queue;
+	spinlock_t              lock_rd;
+	spinlock_t              lock_wr;
+	wait_queue_head_t       wait_queue_rd;
 	u8                      running;
 	enum ssif_state         state;
 	/* Timeout waiting for response */
 	struct timer_list       response_timer;
-	bool                    response_timer_inited;
 	/* Flag to identify a Multi-part Read Transaction */
 	bool                    is_singlepart_read;
 	u8                      nbytes_processed;
@@ -92,30 +107,116 @@ struct ssif_bmc_ctx {
 	u8                      recv_len;
 	/* Block Number of a Multi-part Read Transaction */
 	u8                      block_num;
-	bool                    request_available;
-	bool                    response_in_progress;
-	bool                    busy;
 	bool                    aborting;
 	/* Buffer for SSIF Transaction part*/
 	struct ssif_part_buffer part_buf;
 	struct ipmi_ssif_msg    response;
 	struct ipmi_ssif_msg    request;
-	void			*priv;
-	void (*set_ssif_bmc_status)(struct i2c_client *, bool );
+	struct kfifo fifo;
+	u8 msg_count;
+	ktime_t msg_time;
+	u32 timeout;
+	unsigned long response_timeout;
+	struct gpio_desc *alert;
+	u32 pulse_width;
+#ifdef CONFIG_SEPARATE_SSIF_POSTCODES
+	struct miscdevice       miscdev_post;
+	spinlock_t              lock_post_rd;
+	wait_queue_head_t       wait_queue_post_rd;
+	u8                      running_post;
+	struct kfifo fifo_post;
+#endif //CONFIG_SEPARATE_SSIF_POSTCODES
+	struct ast2600_ara *ara;
 };
 
-void npcm_i2c_client_slave_enable(struct i2c_client *client, bool enable);
+static ssize_t ssif_timeout_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ssif_bmc_ctx *ssif_bmc = i2c_get_clientdata(client);
+
+	return sprintf(buf, "%lu\n", ssif_bmc->response_timeout);
+}
+
+static ssize_t ssif_timeout_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct ssif_bmc_ctx *ssif_bmc = i2c_get_clientdata(client);
+
+	ssif_bmc->response_timeout = strtoul (buf, NULL, 10);
+	return count;
+}
+static DEVICE_ATTR_RW(ssif_timeout);
+
+void disable_ast2600_slave(struct i2c_client *client)
+{
+	u32 addr_reg_val;
+	struct aspeed_i2c_bus *bus;
+
+	if (!client)
+		return;
+	/*
+	 * trick: for i2c-ast2600 driver the correct struct should be
+	 * 'struct ast2600_i2c_bus' instead of 'struct aspeed_i2c_bus'.
+	 * However the first three members in both structs are the same:
+	 *
+	 *     struct i2c_adapter		adap;
+	 *     struct device			*dev;
+	 *     void __iomem			*reg_base;
+	 *
+	 * Here we only use bus->base so it's harmless to still refer as
+	 * 'struct aspeed_i2c_bus'.
+	 */
+	bus = i2c_get_adapdata(client->adapter);
+	addr_reg_val = readl(bus->base + I2C_SLAVE_ADDR_REG);
+	if ((addr_reg_val & 0x7F) == client->addr)
+	{//THIS BIT CANNOT BE DISABLED WITH OLD REGISTER MODE
+		addr_reg_val &= 0xFFFFFF7F;
+		writel(addr_reg_val, bus->base + I2C_SLAVE_ADDR_REG);
+	}
+	if (((addr_reg_val >> 8) & 0x7F) == client->addr)
+	{
+		addr_reg_val &= 0xFFFF7FFF;
+		writel(addr_reg_val, bus->base + I2C_SLAVE_ADDR_REG);
+	}
+	if (((addr_reg_val >> 16) & 0x7F) == client->addr)
+	{
+		addr_reg_val &= 0xFF7FFFFF;
+		writel(addr_reg_val, bus->base + I2C_SLAVE_ADDR_REG);
+	}
+}
 
-static void npcm_ssif_enable(struct ssif_bmc_ctx *ssif_bmc)
+void enable_ast2600_slave(struct i2c_client *client)
 {
-	if(ssif_bmc->busy) {
-		if (ssif_bmc->set_ssif_bmc_status)
-			ssif_bmc->set_ssif_bmc_status(ssif_bmc->client, SSIF_BMC_BUSY);
-	} else
-		if (ssif_bmc->set_ssif_bmc_status)
-			ssif_bmc->set_ssif_bmc_status(ssif_bmc->client, SSIF_BMC_READY);
+	u32 addr_reg_val;
+	struct aspeed_i2c_bus *bus;
+
+	if (!client)
+		return;
+
+	bus = i2c_get_adapdata(client->adapter);
+	addr_reg_val = readl(bus->base + I2C_SLAVE_ADDR_REG);
+	if ((addr_reg_val & 0x7F) == client->addr)
+	{
+		addr_reg_val |= 0x80;
+		writel(addr_reg_val, bus->base + I2C_SLAVE_ADDR_REG);
+	}
+	else if (((addr_reg_val >> 8) & 0x7F) == client->addr)
+	{
+		addr_reg_val |= 0x8000;
+		writel(addr_reg_val, bus->base + I2C_SLAVE_ADDR_REG);
+	}
+	else if (((addr_reg_val >> 16) & 0x7F) == client->addr)
+	{
+		addr_reg_val |= 0x800000;
+		writel(addr_reg_val, bus->base + I2C_SLAVE_ADDR_REG);
+	}
 }
 
+
 static inline struct ssif_bmc_ctx *to_ssif_bmc(struct file *file)
 {
 	return container_of(file->private_data, struct ssif_bmc_ctx, miscdev);
@@ -141,45 +242,117 @@ static const char *state_to_string(enum ssif_state state)
 	}
 }
 
-/* Handle SSIF message that will be sent to user */
-static ssize_t ssif_bmc_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+static ssize_t ssif_bmc_read(struct file *file, char __user *buf, size_t count_in, loff_t *ppos)
 {
 	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
-	struct ipmi_ssif_msg msg;
 	unsigned long flags;
-	ssize_t ret;
+	unsigned int count_out;
+	ssize_t ret = 0;
 
-	spin_lock_irqsave(&ssif_bmc->lock, flags);
-	while (!ssif_bmc->request_available) {
-		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
+	if (kfifo_is_empty(&ssif_bmc->fifo)) {
 		if (file->f_flags & O_NONBLOCK)
 			return -EAGAIN;
-		ret = wait_event_interruptible(ssif_bmc->wait_queue,
-					       ssif_bmc->request_available);
-		if (ret)
+		ret = wait_event_interruptible(ssif_bmc->wait_queue_rd, !kfifo_is_empty(&ssif_bmc->fifo));
+		if (ret == -ERESTARTSYS)
+			return ret; 
+	}
+	spin_lock_irqsave(&ssif_bmc->lock_rd, flags);
+	ret = kfifo_to_user(&ssif_bmc->fifo, buf, count_in, &count_out);
+	spin_unlock_irqrestore(&ssif_bmc->lock_rd, flags);
+	return (ret < 0) ? ret : count_out;
+}
+
+#ifdef CONFIG_SEPARATE_SSIF_POSTCODES
+static inline struct ssif_bmc_ctx *to_ssif_bmc_post(struct file *file)
+{
+	return container_of(file->private_data, struct ssif_bmc_ctx, miscdev_post);
+}
+
+
+static ssize_t ssif_bmc_read_post(struct file *file, char __user *buf, size_t count_in, loff_t *ppos)
+{
+	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc_post(file);
+	unsigned long flags;
+	unsigned int count_out;
+	ssize_t ret = 0;
+
+	if (kfifo_is_empty(&ssif_bmc->fifo_post)) {
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		ret = wait_event_interruptible(ssif_bmc->wait_queue_post_rd, !kfifo_is_empty(&ssif_bmc->fifo_post));
+		if (ret == -ERESTARTSYS)
 			return ret;
-		spin_lock_irqsave(&ssif_bmc->lock, flags);
 	}
+	spin_lock_irqsave(&ssif_bmc->lock_post_rd, flags);
+	ret = kfifo_to_user(&ssif_bmc->fifo_post, buf, count_in, &count_out);
+	spin_unlock_irqrestore(&ssif_bmc->lock_post_rd, flags);
+	return (ret < 0) ? ret : count_out;
+}
 
-	if (count < min_t(ssize_t,
-			  sizeof_field(struct ipmi_ssif_msg, len) + ssif_bmc->request.len,
-			  sizeof(struct ipmi_ssif_msg))) {
-		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-		ret = -EINVAL;
-	} else {
-		count = min_t(ssize_t,
-			      sizeof_field(struct ipmi_ssif_msg, len) + ssif_bmc->request.len,
-			      sizeof(struct ipmi_ssif_msg));
-		memcpy(&msg, &ssif_bmc->request, count);
-		ssif_bmc->request_available = false;
-		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
+static int ssif_bmc_open_post(struct inode *inode, struct file *file)
+{
+	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc_post(file);
+	int ret = 0;
+
+	if (!ssif_bmc->running_post)
+		ssif_bmc->running_post = 1;
+	else
+		ret = -EBUSY;
+
+	return ret;
+}
 
-		ret = copy_to_user(buf, &msg, count);
+static __poll_t ssif_bmc_poll_post(struct file *file, poll_table *wait)
+{
+	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc_post(file);
+
+	poll_wait(file, &ssif_bmc->wait_queue_post_rd, wait);
+	if (!kfifo_is_empty(&ssif_bmc->fifo_post)) {
+		return POLLIN | POLLRDNORM;
 	}
+	return 0;
+}
 
-	return (ret < 0) ? ret : count;
+static int ssif_bmc_release_post(struct inode *inode, struct file *file)
+{
+	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc_post(file);
+
+	ssif_bmc->running_post = 0;
+
+	return 0;
 }
 
+static const struct file_operations ssif_bmc_post_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ssif_bmc_open_post,
+	.read		= ssif_bmc_read_post,
+	.release	= ssif_bmc_release_post,
+	.poll		= ssif_bmc_poll_post,
+};
+
+void send_post_code(struct ssif_bmc_ctx *ssif_bmc)
+{
+	unsigned long flags = 0;
+	int rc = 0;
+
+	if (kfifo_initialized(&ssif_bmc->fifo_post) && ssif_bmc->request.header.len >= (POST_CODE_SIZE + POST_CODE_OFFSET)) {
+		ssize_t to_send = POST_CODE_SIZE;
+		spin_lock_irqsave(&ssif_bmc->lock_post_rd, flags);
+		if ((BUFFER_SIZE - kfifo_len(&ssif_bmc->fifo_post)) < to_send)
+			kfifo_reset(&ssif_bmc->fifo_post);
+		rc = kfifo_in(&ssif_bmc->fifo_post, &ssif_bmc->request.payload[POST_CODE_OFFSET], to_send);
+		if (rc != to_send) {
+			kfifo_reset(&ssif_bmc->fifo_post);
+			spin_unlock_irqrestore(&ssif_bmc->lock_post_rd, flags);
+			return;
+		}
+		spin_unlock_irqrestore(&ssif_bmc->lock_post_rd, flags);
+
+		wake_up_all(&ssif_bmc->wait_queue_post_rd);
+	}
+}
+#endif //CONFIG_SEPARATE_SSIF_POSTCODES
+
 /* Handle SSIF message that is written by user */
 static ssize_t ssif_bmc_write(struct file *file, const char __user *buf, size_t count,
 			      loff_t *ppos)
@@ -188,55 +361,50 @@ static ssize_t ssif_bmc_write(struct file *file, const char __user *buf, size_t
 	struct ipmi_ssif_msg msg;
 	unsigned long flags;
 	ssize_t ret;
+	ktime_t delta;
+	ktime_t now;
+	s64 timer;
 
-	if (count < sizeof(msg.len) ||
-	    count > sizeof(struct ipmi_ssif_msg))
+	if (count > sizeof(struct ipmi_ssif_msg))
 		return -EINVAL;
 
 	if (copy_from_user(&msg, buf, count))
 		return -EFAULT;
 
-	if (!msg.len || msg.len > IPMI_SSIF_PAYLOAD_MAX ||
-	    count < sizeof_field(struct ipmi_ssif_msg, len) + msg.len)
-		return -EINVAL;
-
-	spin_lock_irqsave(&ssif_bmc->lock, flags);
-	while (ssif_bmc->response_in_progress) {
-		spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-		if (file->f_flags & O_NONBLOCK)
-			return -EAGAIN;
-		ret = wait_event_interruptible(ssif_bmc->wait_queue,
-					       !ssif_bmc->response_in_progress);
-		if (ret)
-			return ret;
-		spin_lock_irqsave(&ssif_bmc->lock, flags);
+	//the message count must match, otherwise it is wrong message
+	//tell upper layers that all is fine even though the message was dropped by the user
+	if (msg.header.msg_num != ssif_bmc->msg_count) {
+		return count;
 	}
 
-	/*
-	 * The write must complete before the response timeout fired, otherwise
-	 * the response is aborted and wait for next request
-	 * Return -EINVAL if the response is aborted
-	 */
-	ret = (ssif_bmc->response_timer_inited) ? 0 : -EINVAL;
-	if (ret)
-		goto exit;
-
-	del_timer(&ssif_bmc->response_timer);
-	ssif_bmc->response_timer_inited = false;
+	if (!msg.header.len || count < sizeof(struct ipmi_ssif_msg_header) + msg.header.len) {
+		return -EINVAL;
+	}
+	now = ktime_get();
+	delta = ktime_sub(now, ssif_bmc->msg_time);
+	timer = ktime_to_ms(delta);
+	if (timer > (s64)(ssif_bmc->timeout))
+		return -EPERM;
 
+	spin_lock_irqsave(&ssif_bmc->lock_wr, flags);
 	memcpy(&ssif_bmc->response, &msg, count);
-	ssif_bmc->is_singlepart_read = (msg.len <= MAX_PAYLOAD_PER_TRANSACTION);
-
-	ssif_bmc->response_in_progress = true;
-
-	/* ssif_bmc not busy */
-	ssif_bmc->busy = false;
+	ssif_bmc->is_singlepart_read = (msg.header.len <= MAX_PAYLOAD_PER_TRANSACTION);
+	spin_unlock_irqrestore(&ssif_bmc->lock_wr, flags);
+
+	del_timer_sync(&ssif_bmc->response_timer);
+	enable_ast2600_slave(ssif_bmc->client);
+
+	if (!IS_ERR(ssif_bmc->alert)) {
+		enable_ast2600_ara(ssif_bmc->client);
+		//if gpio is already asserted toggle it
+		if (gpiod_get_value(ssif_bmc->alert))
+		{
+			gpiod_set_value(ssif_bmc->alert, 0);
+			udelay(ssif_bmc->pulse_width);
+		}
 
-	/* Clean old request buffer */
-	memset(&ssif_bmc->request, 0, sizeof(struct ipmi_ssif_msg));
-exit:
-	npcm_ssif_enable(ssif_bmc);
-	spin_unlock_irqrestore(&ssif_bmc->lock, flags);
+		gpiod_set_value(ssif_bmc->alert, 1);
+	}
 
 	return (ret < 0) ? ret : count;
 }
@@ -246,12 +414,10 @@ static int ssif_bmc_open(struct inode *inode, struct file *file)
 	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
 	int ret = 0;
 
-	spin_lock_irq(&ssif_bmc->lock);
 	if (!ssif_bmc->running)
 		ssif_bmc->running = 1;
 	else
 		ret = -EBUSY;
-	spin_unlock_irq(&ssif_bmc->lock);
 
 	return ret;
 }
@@ -259,30 +425,19 @@ static int ssif_bmc_open(struct inode *inode, struct file *file)
 static __poll_t ssif_bmc_poll(struct file *file, poll_table *wait)
 {
 	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
-	__poll_t mask = 0;
-
-	poll_wait(file, &ssif_bmc->wait_queue, wait);
-
-	spin_lock_irq(&ssif_bmc->lock);
-	/* The request is available, userspace application can get the request */
-	if (ssif_bmc->request_available)
-		mask |= EPOLLIN;
-
-	if(!ssif_bmc->response_in_progress)
-		mask |= EPOLLOUT;
-
-	spin_unlock_irq(&ssif_bmc->lock);
 
-	return mask;
+	poll_wait(file, &ssif_bmc->wait_queue_rd, wait);
+	if (!kfifo_is_empty(&ssif_bmc->fifo)) {
+		return POLLIN | POLLRDNORM;
+	}
+	return 0;
 }
 
 static int ssif_bmc_release(struct inode *inode, struct file *file)
 {
 	struct ssif_bmc_ctx *ssif_bmc = to_ssif_bmc(file);
 
-	spin_lock_irq(&ssif_bmc->lock);
 	ssif_bmc->running = 0;
-	spin_unlock_irq(&ssif_bmc->lock);
 
 	return 0;
 }
@@ -300,59 +455,50 @@ static const struct file_operations ssif_bmc_fops = {
 };
 
 /* Called with ssif_bmc->lock held. */
-static void complete_response(struct ssif_bmc_ctx *ssif_bmc)
-{
-	/* Invalidate response in buffer to denote it having been sent. */
-	ssif_bmc->response.len = 0;
-	ssif_bmc->response_in_progress = false;
-	ssif_bmc->nbytes_processed = 0;
-	ssif_bmc->remain_len = 0;
-	ssif_bmc->busy = false;
-	wake_up_all(&ssif_bmc->wait_queue);
-}
-
-static void response_timeout(struct timer_list *t)
+static void handle_request(struct ssif_bmc_ctx *ssif_bmc)
 {
-	struct ssif_bmc_ctx *ssif_bmc = from_timer(ssif_bmc, t, response_timer);
-	unsigned long flags;
-
-	spin_lock_irqsave(&ssif_bmc->lock, flags);
-
-	/* Do nothing if the response is in progress */
-	if (!ssif_bmc->response_in_progress) {
-		/* Recover ssif_bmc from busy */
-		ssif_bmc->response_timer_inited = false;
-		dev_warn(&ssif_bmc->client->dev,
-			 "%s: No response from userspace, abort current request\n", __func__);
-		/* Set aborting flag */
-		ssif_bmc->aborting = true;
-	}
+	unsigned long flags = 0;
+	int rc = 0;
+#ifdef CONFIG_SEPARATE_SSIF_POSTCODES
+	int netfn = ssif_bmc->request.payload[0] >> 2;
+	int cmd = ssif_bmc->request.payload[1];
+	int group = ssif_bmc->request.payload[2];
+
+	if (netfn == 0x2c && cmd == 0x2 && group == 0xAE)
+		send_post_code(ssif_bmc);
+	else
+#endif //CONFIG_SEPARATE_SSIF_POSTCODES
+	if (kfifo_initialized(&ssif_bmc->fifo)) {
+		ssize_t to_send = sizeof(struct ipmi_ssif_msg_header) + ssif_bmc->request.header.len;
+		if (to_send > BUFFER_SIZE) {
+			return;
+		}
 
-	ssif_bmc->busy = false;
-	npcm_ssif_enable(ssif_bmc);
-	spin_unlock_irqrestore(&ssif_bmc->lock, flags);
-}
+		if ((BUFFER_SIZE - kfifo_len(&ssif_bmc->fifo)) < to_send)
+			kfifo_reset(&ssif_bmc->fifo);
 
-/* Called with ssif_bmc->lock held. */
-static void handle_request(struct ssif_bmc_ctx *ssif_bmc)
-{
-	/* set ssif_bmc to busy waiting for response */
-	ssif_bmc->busy = true;
-	npcm_ssif_enable(ssif_bmc);
+		spin_lock_irqsave(&ssif_bmc->lock_rd, flags);
+		rc = kfifo_in(&ssif_bmc->fifo, &ssif_bmc->request.header,  sizeof(struct ipmi_ssif_msg_header));
+		if (rc != sizeof(struct ipmi_ssif_msg_header)) {
+			kfifo_reset(&ssif_bmc->fifo);
+			spin_unlock_irqrestore(&ssif_bmc->lock_rd, flags);
+			return;
+		}
+		to_send = min_t(ssize_t, ssif_bmc->request.header.len, IPMI_SSIF_PAYLOAD_MAX);
+		rc = kfifo_in(&ssif_bmc->fifo, ssif_bmc->request.payload, to_send);
+		spin_unlock_irqrestore(&ssif_bmc->lock_rd, flags);
+		if (rc != to_send) {
+			kfifo_reset(&ssif_bmc->fifo);
+			return;
+		}
 
-	/* Request message is available to process */
-	ssif_bmc->request_available = true;
-	/* Clean old response buffer */
-	memset(&ssif_bmc->response, 0, sizeof(struct ipmi_ssif_msg));
-	/* This is the new READ request.*/
-	wake_up_all(&ssif_bmc->wait_queue);
+		disable_ast2600_slave(ssif_bmc->client);
+		mod_timer(&ssif_bmc->response_timer, jiffies + msecs_to_jiffies(ssif_bmc->response_timeout));
 
-	/* Armed timer to recover slave from busy state in case of no response */
-	if (!ssif_bmc->response_timer_inited) {
-		timer_setup(&ssif_bmc->response_timer, response_timeout, 0);
-		ssif_bmc->response_timer_inited = true;
+		memset(&ssif_bmc->response, 0, sizeof(struct ipmi_ssif_msg_header));
+		ssif_bmc->msg_time = ktime_get();
+		wake_up_all(&ssif_bmc->wait_queue_rd);
 	}
-	mod_timer(&ssif_bmc->response_timer, jiffies + msecs_to_jiffies(RESPONSE_TIMEOUT));
 }
 
 static void calculate_response_part_pec(struct ssif_part_buffer *part)
@@ -374,18 +520,21 @@ static void calculate_response_part_pec(struct ssif_part_buffer *part)
 static void set_singlepart_response_buffer(struct ssif_bmc_ctx *ssif_bmc)
 {
 	struct ssif_part_buffer *part = &ssif_bmc->part_buf;
+	unsigned long flags;
 
 	part->address = GET_8BIT_ADDR(ssif_bmc->client->addr);
-	part->length = (u8)ssif_bmc->response.len;
-
+	spin_lock_irqsave(&ssif_bmc->lock_wr, flags);
+	part->length = (u8)ssif_bmc->response.header.len;
 	/* Clear the rest to 0 */
 	memset(part->payload + part->length, 0, MAX_PAYLOAD_PER_TRANSACTION - part->length);
 	memcpy(&part->payload[0], &ssif_bmc->response.payload[0], part->length);
+	spin_unlock_irqrestore(&ssif_bmc->lock_wr, flags);
 }
 
 static void set_multipart_response_buffer(struct ssif_bmc_ctx *ssif_bmc)
 {
 	struct ssif_part_buffer *part = &ssif_bmc->part_buf;
+	unsigned long flags;
 	u8 part_len = 0;
 
 	part->address = GET_8BIT_ADDR(ssif_bmc->client->addr);
@@ -400,12 +549,14 @@ static void set_multipart_response_buffer(struct ssif_bmc_ctx *ssif_bmc)
 		ssif_bmc->block_num = 0;
 		part->length = MAX_PAYLOAD_PER_TRANSACTION;
 		part_len = MAX_IPMI_DATA_PER_START_TRANSACTION;
-		ssif_bmc->remain_len = ssif_bmc->response.len - part_len;
+		spin_lock_irqsave(&ssif_bmc->lock_wr, flags);
+		ssif_bmc->remain_len = ssif_bmc->response.header.len - part_len;
 
 		part->payload[0] = 0x00; /* Start Flag */
 		part->payload[1] = 0x01; /* Start Flag */
 
 		memcpy(&part->payload[2], &ssif_bmc->response.payload[0], part_len);
+		spin_unlock_irqrestore(&ssif_bmc->lock_wr, flags);
 		break;
 
 	case SSIF_IPMI_MULTIPART_READ_MIDDLE:
@@ -441,14 +592,18 @@ static void set_multipart_response_buffer(struct ssif_bmc_ctx *ssif_bmc)
 		}
 
 		ssif_bmc->remain_len -= part_len;
+		spin_lock_irqsave(&ssif_bmc->lock_wr, flags);
 		memcpy(&part->payload[1], ssif_bmc->response.payload + ssif_bmc->nbytes_processed,
 		       part_len);
+		spin_unlock_irqrestore(&ssif_bmc->lock_wr, flags);
 		break;
 
 	default:
 		/* Do not expect to go to this case */
 		dev_err(&ssif_bmc->client->dev, "%s: Unexpected SMBus command 0x%x\n",
 			__func__, part->smbus_cmd);
+		part->length = 1;
+		part->payload[0] = 0;
 		break;
 	}
 
@@ -565,17 +720,19 @@ static void process_request_part(struct ssif_bmc_ctx *ssif_bmc)
 	switch (part->smbus_cmd) {
 	case SSIF_IPMI_SINGLEPART_WRITE:
 		/* save the whole part to request*/
-		ssif_bmc->request.len = part->length;
+		ssif_bmc->request.header.len = part->length;
+		ssif_bmc->request.header.msg_num = ssif_bmc->msg_count;
 		memcpy(ssif_bmc->request.payload, part->payload, part->length);
 
 		break;
 	case SSIF_IPMI_MULTIPART_WRITE_START:
-		ssif_bmc->request.len = 0;
+		ssif_bmc->request.header.len = 0;
+		ssif_bmc->request.header.msg_num = ssif_bmc->msg_count;
 
 		fallthrough;
 	case SSIF_IPMI_MULTIPART_WRITE_MIDDLE:
 	case SSIF_IPMI_MULTIPART_WRITE_END:
-		len = ssif_bmc->request.len + part->length;
+		len = ssif_bmc->request.header.len + part->length;
 		/* Do the bound check here, not allow the request len exceed 254 bytes */
 		if (len > IPMI_SSIF_PAYLOAD_MAX) {
 			dev_warn(&ssif_bmc->client->dev,
@@ -583,9 +740,9 @@ static void process_request_part(struct ssif_bmc_ctx *ssif_bmc)
 			/* Request too long, aborting */
 			ssif_bmc->aborting =  true;
 		} else {
-			memcpy(ssif_bmc->request.payload + ssif_bmc->request.len,
+			memcpy(ssif_bmc->request.payload + ssif_bmc->request.header.len,
 			       part->payload, part->length);
-			ssif_bmc->request.len += part->length;
+			ssif_bmc->request.header.len += part->length;
 		}
 		break;
 	default:
@@ -604,22 +761,24 @@ static void process_smbus_cmd(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 	memset(&ssif_bmc->part_buf.payload[0], 0, MAX_PAYLOAD_PER_TRANSACTION);
 
 	if (*val == SSIF_IPMI_SINGLEPART_WRITE || *val == SSIF_IPMI_MULTIPART_WRITE_START) {
-		/*
-		 * The response maybe not come in-time, causing host SSIF driver
-		 * to timeout and resend a new request. In such case check for
-		 * pending response and clear it
-		 */
-		if (ssif_bmc->response_in_progress)
-			complete_response(ssif_bmc);
-
+		if (!IS_ERR(ssif_bmc->alert))
+			gpiod_set_value(ssif_bmc->alert, 0);
 		/* This is new request, flip aborting flag if set */
 		if (ssif_bmc->aborting)
 			ssif_bmc->aborting = false;
+		ssif_bmc->msg_count++;
 	}
 }
 
 static void on_read_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
+	/*
+	 * In SMBUS spec, the byte-count cannot be 0.
+	 * Send byte-count = 1 if there is nothing to send.
+	 */
+
+	*val = 1;
+
 	if (ssif_bmc->state == SSIF_READY ||
 	    ssif_bmc->state == SSIF_START ||
 	    ssif_bmc->state == SSIF_REQ_RECVING ||
@@ -628,7 +787,6 @@ static void on_read_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 			 "Warn: %s unexpected READ REQUESTED in state=%s\n",
 			 __func__, state_to_string(ssif_bmc->state));
 		ssif_bmc->state = SSIF_ABORTING;
-		*val = 0;
 		return;
 
 	} else if (ssif_bmc->state == SSIF_SMBUS_CMD) {
@@ -646,9 +804,7 @@ static void on_read_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 	ssif_bmc->msg_idx = 0;
 
-	/* Send 0 if there is nothing to send */
-	if (!ssif_bmc->response_in_progress || ssif_bmc->state == SSIF_ABORTING) {
-		*val = 0;
+	if (ssif_bmc->state == SSIF_ABORTING) {
 		return;
 	}
 
@@ -659,7 +815,12 @@ static void on_read_requested_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 
 	calculate_response_part_pec(&ssif_bmc->part_buf);
 	ssif_bmc->part_buf.index = 0;
-	*val = ssif_bmc->part_buf.length;
+
+	if (ssif_bmc->part_buf.length > 0)
+		*val = ssif_bmc->part_buf.length;
+
+	if (!IS_ERR(ssif_bmc->alert))
+		gpiod_set_value(ssif_bmc->alert, 0);
 }
 
 static void on_read_processed_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
@@ -677,7 +838,7 @@ static void on_read_processed_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 	}
 
 	/* Send 0 if there is nothing to send */
-	if (!ssif_bmc->response_in_progress || ssif_bmc->state == SSIF_ABORTING) {
+	if (ssif_bmc->state == SSIF_ABORTING) {
 		*val = 0;
 		return;
 	}
@@ -740,15 +901,13 @@ static void on_stop_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 {
 	if (ssif_bmc->state == SSIF_READY ||
 	    ssif_bmc->state == SSIF_START ||
-	    ssif_bmc->state == SSIF_SMBUS_CMD) {
+	    ssif_bmc->state == SSIF_SMBUS_CMD ||
+	    ssif_bmc->state == SSIF_ABORTING) {
 		dev_warn(&ssif_bmc->client->dev,
 			 "Warn: %s unexpected SLAVE STOP in state=%s\n",
 			 __func__, state_to_string(ssif_bmc->state));
 		ssif_bmc->state = SSIF_READY;
 
-	} else if (ssif_bmc->state == SSIF_ABORTING) {
-		ssif_bmc->state = SSIF_READY;
-
 	} else if (ssif_bmc->state == SSIF_REQ_RECVING) {
 		if (validate_request_part(ssif_bmc)) {
 			process_request_part(ssif_bmc);
@@ -766,11 +925,6 @@ static void on_stop_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
 			ssif_bmc->aborting = true;
 		}
 	} else if (ssif_bmc->state == SSIF_RES_SENDING) {
-		if (ssif_bmc->is_singlepart_read || ssif_bmc->block_num == 0xFF) {
-			memset(&ssif_bmc->part_buf, 0, sizeof(struct ssif_part_buffer));
-			/* Invalidate response buffer to denote it is sent */
-			complete_response(ssif_bmc);
-		}
 		ssif_bmc->state = SSIF_READY;
 	}
 
@@ -783,12 +937,9 @@ static void on_stop_event(struct ssif_bmc_ctx *ssif_bmc, u8 *val)
  */
 static int ssif_bmc_cb(struct i2c_client *client, enum i2c_slave_event event, u8 *val)
 {
-	unsigned long flags;
 	struct ssif_bmc_ctx *ssif_bmc = i2c_get_clientdata(client);
 	int ret = 0;
 
-	spin_lock_irqsave(&ssif_bmc->lock, flags);
-
 	switch (event) {
 	case I2C_SLAVE_READ_REQUESTED:
 		on_read_requested_event(ssif_bmc, val);
@@ -815,12 +966,15 @@ static int ssif_bmc_cb(struct i2c_client *client, enum i2c_slave_event event, u8
 		break;
 	}
 
-	if (!ssif_bmc->aborting && ssif_bmc->busy)
-		ret = -EBUSY;
+	return ret;
+}
 
-	spin_unlock_irqrestore(&ssif_bmc->lock, flags);
+static void retry_timeout(struct timer_list *t)
+{
+	struct ssif_bmc_ctx *ssif_bmc = from_timer(ssif_bmc, t, response_timer);
 
-	return ret;
+	dev_warn(&ssif_bmc->client->dev, "Userspace did not respond in time. Force enable i2c target\n");
+	enable_ast2600_slave(ssif_bmc->client);
 }
 
 static int ssif_bmc_probe(struct i2c_client *client)
@@ -832,13 +986,26 @@ static int ssif_bmc_probe(struct i2c_client *client)
 	if (!ssif_bmc)
 		return -ENOMEM;
 
-	spin_lock_init(&ssif_bmc->lock);
+	/* Request GPIO for alerting the host that response is ready */
+	ssif_bmc->alert = devm_gpiod_get(&client->dev, "alert", GPIOD_OUT_LOW);
+
+	if (of_property_read_u32(client->dev.of_node, "timeout_ms", &ssif_bmc->timeout))
+		ssif_bmc->timeout = 250;
+	if (of_property_read_u32(client->dev.of_node, "pulse_width_us", &ssif_bmc->pulse_width))
+		ssif_bmc->pulse_width = 5;
+
+	ssif_bmc->response_timeout = ssif_bmc->timeout + 5;
+
+	ret = kfifo_alloc(&ssif_bmc->fifo, BUFFER_SIZE, GFP_KERNEL);
+	if (ret)
+		return ret;
+
+	ssif_bmc->msg_count = 0;
+	ssif_bmc->running = 0;
+	spin_lock_init(&ssif_bmc->lock_rd);
+	spin_lock_init(&ssif_bmc->lock_wr);
 
-	init_waitqueue_head(&ssif_bmc->wait_queue);
-	ssif_bmc->request_available = false;
-	ssif_bmc->response_in_progress = false;
-	ssif_bmc->busy = false;
-	ssif_bmc->response_timer_inited = false;
+	init_waitqueue_head(&ssif_bmc->wait_queue_rd);
 
 	/* Register misc device interface */
 	ssif_bmc->miscdev.minor = MISC_DYNAMIC_MINOR;
@@ -849,18 +1016,43 @@ static int ssif_bmc_probe(struct i2c_client *client)
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_SEPARATE_SSIF_POSTCODES
+	ssif_bmc->running_post = 0;
+	spin_lock_init(&ssif_bmc->lock_post_rd);
+	init_waitqueue_head(&ssif_bmc->wait_queue_post_rd);
+	ret = kfifo_alloc(&ssif_bmc->fifo_post, BUFFER_SIZE, GFP_KERNEL);
+	if (ret) {
+		misc_deregister(&ssif_bmc->miscdev);
+		return ret;
+	}
+	ssif_bmc->miscdev_post.minor = MISC_DYNAMIC_MINOR;
+	ssif_bmc->miscdev_post.name = DEVICE_NAME_POST;
+	ssif_bmc->miscdev_post.fops = &ssif_bmc_post_fops;
+	ssif_bmc->miscdev_post.parent = &client->dev;
+	ret = misc_register(&ssif_bmc->miscdev_post);
+	if (ret) {
+		misc_deregister(&ssif_bmc->miscdev);
+		return ret;
+	}
+#endif //CONFIG_SEPARATE_SSIF_POSTCODES
 	ssif_bmc->client = client;
 	ssif_bmc->client->flags |= I2C_CLIENT_SLAVE;
-	ssif_bmc->priv = i2c_get_adapdata(client->adapter);
-	ssif_bmc->set_ssif_bmc_status = npcm_i2c_client_slave_enable;
-	npcm_ssif_enable(ssif_bmc);
 
+	timer_setup(&ssif_bmc->response_timer, retry_timeout, 0);
 	/* Register I2C slave */
 	i2c_set_clientdata(client, ssif_bmc);
 	ret = i2c_slave_register(client, ssif_bmc_cb);
-	if (ret)
+	if (ret) {
 		misc_deregister(&ssif_bmc->miscdev);
+#ifdef CONFIG_SEPARATE_SSIF_POSTCODES
+		misc_deregister(&ssif_bmc->miscdev_post);
+#endif //CONFIG_SEPARATE_SSIF_POSTCODES
+	}
+	ssif_bmc->ara = register_ast2600_ara(client);
 
+	if (!IS_ERR(ssif_bmc->alert))
+		gpiod_set_value(ssif_bmc->alert, 0);
+	device_create_file(&client->dev, &dev_attr_ssif_timeout);
 	return ret;
 }
 
@@ -868,8 +1060,16 @@ static void ssif_bmc_remove(struct i2c_client *client)
 {
 	struct ssif_bmc_ctx *ssif_bmc = i2c_get_clientdata(client);
 
+	unregister_ast2600_ara(ssif_bmc->ara);
+	kfifo_free(&ssif_bmc->fifo);
 	i2c_slave_unregister(client);
 	misc_deregister(&ssif_bmc->miscdev);
+#ifdef CONFIG_SEPARATE_SSIF_POSTCODES
+	kfifo_free(&ssif_bmc->fifo_post);
+	misc_deregister(&ssif_bmc->miscdev_post);
+#endif //CONFIG_SEPARATE_SSIF_POSTCODES
+
+	device_remove_file(&client->dev, &dev_attr_ssif_timeout);
 }
 
 static const struct of_device_id ssif_bmc_match[] = {
diff --git a/include/uapi/linux/ipmi_ssif_bmc.h b/include/uapi/linux/ipmi_ssif_bmc.h
index 1c6a753dad08..e98fcb49688e 100644
--- a/include/uapi/linux/ipmi_ssif_bmc.h
+++ b/include/uapi/linux/ipmi_ssif_bmc.h
@@ -10,8 +10,13 @@
 
 /* Max length of ipmi ssif message included netfn and cmd field */
 #define IPMI_SSIF_PAYLOAD_MAX         254
-struct ipmi_ssif_msg {
+struct ipmi_ssif_msg_header {
 	unsigned int len;
+	u8 msg_num;
+} __attribute((packed));
+
+struct ipmi_ssif_msg {
+	struct ipmi_ssif_msg_header header;
 	__u8    payload[IPMI_SSIF_PAYLOAD_MAX];
 };
 
-- 
2.34.1

