From 97a797649e88f622745b33aa434f33049272eccc Mon Sep 17 00:00:00 2001
From: Jae Hyun Yoo <jae.hyun.yoo@intel.com>
Date: Fri, 15 Feb 2019 16:05:09 -0800
Subject: [PATCH] i2c: Add mux hold/unhold msg types

This commit adds mux hold/unhold message types to support extended
mux control for IPMB and MCTP devices. A hold or an unhold message
can be added at the end of I2C message stream wrapped by
repeated-start, also can be used as a single message independantly.

This mux hold/unhold message will be delivered throughout all mux
levels in the path. Means that if it goes to multi-level mux path,
all muxes will be held/unheld by this message.

1. Hold message
   struct i2c_msg msg;
   uint16_t timeout = 5000; // timeout in ms. 5 secs in this example.

   msg.addr = 0x0; // any value can be used. addr will be ignored in this packet.
   msg.flags = I2C_M_HOLD; // set this flag to indicate it's a hold message.
   msg.len = sizeof(uint16_t); // timeout value will be delivered using two bytes buffer.
   msg.buf = (uint8_t *)&timeout; // set timeout value.

2. Unhold message
   struct i2c_msg msg;
   uint16_t timeout = 0; // set 0 for an unhold message.

   msg.addr = 0x0; // any value can be used. addr will be ignored in this packet.
   msg.flags = I2C_M_HOLD; // set this flag to indicate it's an unhold message.
   msg.len = sizeof(uint16_t); // timeout value will be delivered using two bytes buffer.
   msg.buf = (uint8_t *)&timeout; // set timeout value.

   This unhold message can be delivered to a mux adapter even when
   a bus is locked so that any holding state can be unheld
   immediately by invoking this unhold message.

This patch would not be welcomed from upstream so it should be kept
in downstream only.

Signed-off-by: Jae Hyun Yoo <jae.hyun.yoo@intel.com>
Upstream-Status: Pending [Not submitted to upstream yet]
---
 drivers/i2c/i2c-core-base.c  |  76 ++++++++++++++++++++++--
 drivers/i2c/i2c-core-smbus.c |  22 +++++--
 drivers/i2c/i2c-mux.c        | 112 ++++++++++++++++++++++++++++++++---
 include/linux/i2c-mux.h      |   4 ++
 include/linux/i2c.h          |   3 +-
 5 files changed, 200 insertions(+), 17 deletions(-)

diff --git a/drivers/i2c/i2c-core-base.c b/drivers/i2c/i2c-core-base.c
index 7c810893bfa3..8bdb64ff8048 100644
--- a/drivers/i2c/i2c-core-base.c
+++ b/drivers/i2c/i2c-core-base.c
@@ -1505,6 +1505,27 @@ int i2c_handle_smbus_host_notify(struct i2c_adapter *adap, unsigned short addr)
 }
 EXPORT_SYMBOL_GPL(i2c_handle_smbus_host_notify);
 
+static void i2c_adapter_hold(struct i2c_adapter *adapter, unsigned long timeout)
+{
+	mutex_lock(&adapter->hold_lock);
+	schedule_delayed_work(&adapter->unhold_work, timeout);
+}
+
+static void i2c_adapter_unhold(struct i2c_adapter *adapter)
+{
+	cancel_delayed_work_sync(&adapter->unhold_work);
+	mutex_unlock(&adapter->hold_lock);
+}
+
+static void i2c_adapter_unhold_work(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct i2c_adapter *adapter = container_of(dwork, struct i2c_adapter,
+						   unhold_work);
+
+	mutex_unlock(&adapter->hold_lock);
+}
+
 static int i2c_register_adapter(struct i2c_adapter *adap)
 {
 	int res = -EINVAL;
@@ -1590,6 +1611,9 @@ static int i2c_register_adapter(struct i2c_adapter *adap)
 	bus_for_each_drv(&i2c_bus_type, NULL, adap, __process_new_adapter);
 	mutex_unlock(&core_lock);
 
+	mutex_init(&adap->hold_lock);
+	INIT_DELAYED_WORK(&adap->unhold_work, i2c_adapter_unhold_work);
+
 	return 0;
 
 out_reg:
@@ -1808,6 +1832,8 @@ void i2c_del_adapter(struct i2c_adapter *adap)
 	idr_remove(&i2c_adapter_idr, adap->nr);
 	mutex_unlock(&core_lock);
 
+	i2c_adapter_unhold(adap);
+
 	/* Clear the device structure in case this adapter is ever going to be
 	   added again */
 	memset(&adap->dev, 0, sizeof(adap->dev));
@@ -2210,7 +2236,9 @@ static int i2c_check_for_quirks(struct i2c_adapter *adap, struct i2c_msg *msgs,
  */
 int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 {
+	enum i2c_hold_msg_type hold_msg = I2C_HOLD_MSG_NONE;
 	unsigned long orig_jiffies;
+	unsigned long timeout;
 	int ret, try;
 
 	if (!adap->algo->master_xfer) {
@@ -2228,6 +2256,25 @@ int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 	if (adap->quirks && i2c_check_for_quirks(adap, msgs, num))
 		return -EOPNOTSUPP;
 
+	/* Do not deliver a mux hold msg to root bus adapter */
+	if (!i2c_parent_is_i2c_adapter(adap)) {
+	    hold_msg = i2c_check_hold_msg(msgs[num - 1].flags,
+					   msgs[num - 1].len,
+					  (u16 *)msgs[num - 1].buf);
+		if (hold_msg == I2C_HOLD_MSG_SET) {
+			timeout = msecs_to_jiffies(*(u16 *)msgs[num - 1].buf);
+			i2c_adapter_hold(adap, timeout);
+
+			if (--num == 0)
+				return 0;
+		} else if (hold_msg == I2C_HOLD_MSG_RESET) {
+			i2c_adapter_unhold(adap);
+			return 0;
+		} else if (hold_msg == I2C_HOLD_MSG_NONE) {
+			mutex_lock(&adap->hold_lock);
+		}
+	}
+
 	/*
 	 * i2c_trace_msg_key gets enabled when tracepoint i2c_transfer gets
 	 * enabled.  This is an efficient way of keeping the for-loop from
@@ -2264,6 +2311,13 @@ int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 		trace_i2c_result(adap, num, ret);
 	}
 
+	if (!i2c_parent_is_i2c_adapter(adap)) {
+		if (hold_msg == I2C_HOLD_MSG_SET && ret < 0)
+			i2c_adapter_unhold(adap);
+		else if (hold_msg == I2C_HOLD_MSG_NONE)
+			mutex_unlock(&adap->hold_lock);
+	}
+
 	return ret;
 }
 EXPORT_SYMBOL(__i2c_transfer);
@@ -2282,6 +2336,7 @@ EXPORT_SYMBOL(__i2c_transfer);
  */
 int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 {
+	bool do_bus_lock = true;
 	int ret;
 
 	/* REVISIT the fault reporting model here is weak:
@@ -2300,12 +2355,25 @@ int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 	 *    one (discarding status on the second message) or errno
 	 *    (discarding status on the first one).
 	 */
-	ret = __i2c_lock_bus_helper(adap);
-	if (ret)
-		return ret;
+	/*
+	 * Do not lock a bus for delivering an unhold msg to a mux
+	 * adpater. This is just for a single length unhold msg case.
+	 */
+	if (num == 1 && i2c_parent_is_i2c_adapter(adap) &&
+	    i2c_check_hold_msg(msgs[0].flags, msgs[0].len,
+			       (u16 *)msgs[0].buf) ==
+			       I2C_HOLD_MSG_RESET)
+		do_bus_lock = false;
+
+	if (do_bus_lock) {
+		ret = __i2c_lock_bus_helper(adap);
+		if (ret)
+			return ret;
+	}
 
 	ret = __i2c_transfer(adap, msgs, num);
-	i2c_unlock_bus(adap, I2C_LOCK_SEGMENT);
+	if (do_bus_lock)
+		i2c_unlock_bus(adap, I2C_LOCK_SEGMENT);
 
 	return ret;
 }
diff --git a/drivers/i2c/i2c-core-smbus.c b/drivers/i2c/i2c-core-smbus.c
index e3b96fc53b5c..f5b9615d4b65 100644
--- a/drivers/i2c/i2c-core-smbus.c
+++ b/drivers/i2c/i2c-core-smbus.c
@@ -536,15 +536,29 @@ s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
 		   unsigned short flags, char read_write,
 		   u8 command, int protocol, union i2c_smbus_data *data)
 {
+	bool do_bus_lock = true;
 	s32 res;
 
-	res = __i2c_lock_bus_helper(adapter);
-	if (res)
-		return res;
+	/*
+	 * Do not lock a bus for delivering an unhold msg to a mux adpater.
+	 * This is just for a single length unhold msg case.
+	 */
+	if (i2c_parent_is_i2c_adapter(adapter) &&
+	    i2c_check_hold_msg(flags,
+			       protocol == I2C_SMBUS_WORD_DATA ? 2 : 0,
+			       &data->word) == I2C_HOLD_MSG_RESET)
+		do_bus_lock = false;
+
+	if (do_bus_lock) {
+		res = __i2c_lock_bus_helper(adapter);
+		if (res)
+			return res;
+	}
 
 	res = __i2c_smbus_xfer(adapter, addr, flags, read_write,
 			       command, protocol, data);
-	i2c_unlock_bus(adapter, I2C_LOCK_SEGMENT);
+	if (do_bus_lock)
+		i2c_unlock_bus(adapter, I2C_LOCK_SEGMENT);
 
 	return res;
 }
diff --git a/drivers/i2c/i2c-mux.c b/drivers/i2c/i2c-mux.c
index 953cd1e522be..a988466fa494 100644
--- a/drivers/i2c/i2c-mux.c
+++ b/drivers/i2c/i2c-mux.c
@@ -36,21 +36,61 @@ struct i2c_mux_priv {
 	u32 chan_id;
 };
 
+static void i2c_mux_hold(struct i2c_mux_core *muxc, unsigned long timeout)
+{
+	mutex_lock(&muxc->hold_lock);
+	schedule_delayed_work(&muxc->unhold_work, timeout);
+}
+
+static void i2c_mux_unhold(struct i2c_mux_core *muxc)
+{
+	cancel_delayed_work_sync(&muxc->unhold_work);
+	mutex_unlock(&muxc->hold_lock);
+}
+
+static void i2c_mux_unhold_work(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct i2c_mux_core *muxc = container_of(dwork, struct i2c_mux_core,
+						 unhold_work);
+
+	mutex_unlock(&muxc->hold_lock);
+}
+
 static int __i2c_mux_master_xfer(struct i2c_adapter *adap,
 				 struct i2c_msg msgs[], int num)
 {
 	struct i2c_mux_priv *priv = adap->algo_data;
 	struct i2c_mux_core *muxc = priv->muxc;
 	struct i2c_adapter *parent = muxc->parent;
+	enum i2c_hold_msg_type hold_msg;
+	unsigned long timeout;
 	int ret;
 
 	/* Switch to the right mux port and perform the transfer. */
 
+	hold_msg = i2c_check_hold_msg(msgs[num - 1].flags,
+				      msgs[num - 1].len,
+				      (u16 *)msgs[num - 1].buf);
+	if (hold_msg == I2C_HOLD_MSG_SET) {
+		timeout = msecs_to_jiffies(*(u16 *)msgs[num - 1].buf);
+		i2c_mux_hold(muxc, timeout);
+	} else if (hold_msg == I2C_HOLD_MSG_NONE) {
+		mutex_lock(&muxc->hold_lock);
+	}
 	ret = muxc->select(muxc, priv->chan_id);
 	if (ret >= 0)
 		ret = __i2c_transfer(parent, msgs, num);
-	if (muxc->deselect)
-		muxc->deselect(muxc, priv->chan_id);
+	if (hold_msg != I2C_HOLD_MSG_SET) {
+		if (muxc->deselect)
+			muxc->deselect(muxc, priv->chan_id);
+		if (hold_msg == I2C_HOLD_MSG_RESET)
+			i2c_mux_unhold(muxc);
+		else
+			mutex_unlock(&muxc->hold_lock);
+	} else if (hold_msg == I2C_HOLD_MSG_SET && ret < 0) {
+		i2c_mux_unhold(muxc);
+	}
 
 	return ret;
 }
@@ -61,15 +101,32 @@ static int i2c_mux_master_xfer(struct i2c_adapter *adap,
 	struct i2c_mux_priv *priv = adap->algo_data;
 	struct i2c_mux_core *muxc = priv->muxc;
 	struct i2c_adapter *parent = muxc->parent;
+	enum i2c_hold_msg_type hold_msg;
+	unsigned long timeout;
 	int ret;
 
 	/* Switch to the right mux port and perform the transfer. */
 
+	hold_msg = i2c_check_hold_msg(msgs[num - 1].flags,
+				      msgs[num - 1].len,
+				      (u16 *)msgs[num - 1].buf);
+	if (hold_msg == I2C_HOLD_MSG_SET) {
+		timeout = msecs_to_jiffies(*(u16 *)msgs[num - 1].buf);
+		i2c_mux_hold(muxc, timeout);
+	} else if (hold_msg == I2C_HOLD_MSG_NONE) {
+		mutex_lock(&muxc->hold_lock);
+	}
 	ret = muxc->select(muxc, priv->chan_id);
 	if (ret >= 0)
 		ret = i2c_transfer(parent, msgs, num);
-	if (muxc->deselect)
-		muxc->deselect(muxc, priv->chan_id);
+	if (hold_msg != I2C_HOLD_MSG_SET) {
+		if (muxc->deselect)
+			muxc->deselect(muxc, priv->chan_id);
+		if (hold_msg == I2C_HOLD_MSG_RESET)
+			i2c_mux_unhold(muxc);
+		else
+			mutex_unlock(&muxc->hold_lock);
+	}
 
 	return ret;
 }
@@ -82,16 +139,33 @@ static int __i2c_mux_smbus_xfer(struct i2c_adapter *adap,
 	struct i2c_mux_priv *priv = adap->algo_data;
 	struct i2c_mux_core *muxc = priv->muxc;
 	struct i2c_adapter *parent = muxc->parent;
+	enum i2c_hold_msg_type hold_msg;
+	unsigned long timeout;
 	int ret;
 
 	/* Select the right mux port and perform the transfer. */
 
+	hold_msg = i2c_check_hold_msg(flags,
+				      size == I2C_SMBUS_WORD_DATA ? 2 : 0,
+				      &data->word);
+	if (hold_msg == I2C_HOLD_MSG_SET) {
+		timeout = msecs_to_jiffies(data->word);
+		i2c_mux_hold(muxc, timeout);
+	} else if (hold_msg == I2C_HOLD_MSG_NONE) {
+		mutex_lock(&muxc->hold_lock);
+	}
 	ret = muxc->select(muxc, priv->chan_id);
 	if (ret >= 0)
 		ret = __i2c_smbus_xfer(parent, addr, flags,
 				       read_write, command, size, data);
-	if (muxc->deselect)
-		muxc->deselect(muxc, priv->chan_id);
+	if (hold_msg != I2C_HOLD_MSG_SET) {
+		if (muxc->deselect)
+			muxc->deselect(muxc, priv->chan_id);
+		if (hold_msg == I2C_HOLD_MSG_RESET)
+			i2c_mux_unhold(muxc);
+		else
+			mutex_unlock(&muxc->hold_lock);
+	}
 
 	return ret;
 }
@@ -104,16 +178,33 @@ static int i2c_mux_smbus_xfer(struct i2c_adapter *adap,
 	struct i2c_mux_priv *priv = adap->algo_data;
 	struct i2c_mux_core *muxc = priv->muxc;
 	struct i2c_adapter *parent = muxc->parent;
+	enum i2c_hold_msg_type hold_msg;
+	unsigned long timeout;
 	int ret;
 
 	/* Select the right mux port and perform the transfer. */
 
+	hold_msg = i2c_check_hold_msg(flags,
+				      size == I2C_SMBUS_WORD_DATA ? 2 : 0,
+				      &data->word);
+	if (hold_msg == I2C_HOLD_MSG_SET) {
+		timeout = msecs_to_jiffies(data->word);
+		i2c_mux_hold(muxc, timeout);
+	} else if (hold_msg == I2C_HOLD_MSG_NONE) {
+		mutex_lock(&muxc->hold_lock);
+	}
 	ret = muxc->select(muxc, priv->chan_id);
 	if (ret >= 0)
 		ret = i2c_smbus_xfer(parent, addr, flags,
 				     read_write, command, size, data);
-	if (muxc->deselect)
-		muxc->deselect(muxc, priv->chan_id);
+	if (hold_msg != I2C_HOLD_MSG_SET) {
+		if (muxc->deselect)
+			muxc->deselect(muxc, priv->chan_id);
+		if (hold_msg == I2C_HOLD_MSG_RESET)
+			i2c_mux_unhold(muxc);
+		else
+			mutex_unlock(&muxc->hold_lock);
+	}
 
 	return ret;
 }
@@ -251,6 +342,9 @@ struct i2c_mux_core *i2c_mux_alloc(struct i2c_adapter *parent,
 	muxc->deselect = deselect;
 	muxc->max_adapters = max_adapters;
 
+	mutex_init(&muxc->hold_lock);
+	INIT_DELAYED_WORK(&muxc->unhold_work, i2c_mux_unhold_work);
+
 	return muxc;
 }
 EXPORT_SYMBOL_GPL(i2c_mux_alloc);
@@ -424,6 +518,8 @@ void i2c_mux_del_adapters(struct i2c_mux_core *muxc)
 {
 	char symlink_name[20];
 
+	i2c_mux_unhold(muxc);
+
 	while (muxc->num_adapters) {
 		struct i2c_adapter *adap = muxc->adapter[--muxc->num_adapters];
 		struct i2c_mux_priv *priv = adap->algo_data;
diff --git a/include/linux/i2c-mux.h b/include/linux/i2c-mux.h
index 1784ac7afb11..dbe3d70aa320 100644
--- a/include/linux/i2c-mux.h
+++ b/include/linux/i2c-mux.h
@@ -14,6 +14,7 @@
 #ifdef __KERNEL__
 
 #include <linux/bitops.h>
+#include <linux/workqueue.h>
 
 struct i2c_mux_core {
 	struct i2c_adapter *parent;
@@ -27,6 +28,9 @@ struct i2c_mux_core {
 	int (*select)(struct i2c_mux_core *, u32 chan_id);
 	int (*deselect)(struct i2c_mux_core *, u32 chan_id);
 
+	struct mutex hold_lock; /* mutex for channel holding */
+	struct delayed_work unhold_work;
+
 	int num_adapters;
 	int max_adapters;
 	struct i2c_adapter *adapter[];
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 4bcd4516ef1c..d7695ac552b7 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -21,6 +21,7 @@
 #include <linux/irqdomain.h>		/* for Host Notify IRQ */
 #include <linux/of.h>		/* for struct device_node */
 #include <linux/swab.h>		/* for swab16 */
+#include <linux/workqueue.h>
 #include <uapi/linux/i2c.h>
 
 extern const struct bus_type i2c_bus_type;
@@ -772,7 +773,7 @@ struct i2c_adapter {
 	 * has these individually.
 	 */
 	struct mutex hold_lock; /* mutex for bus holding */
-	struct timer_list hold_timer;
+	struct delayed_work unhold_work;
 };
 #define to_i2c_adapter(d) container_of(d, struct i2c_adapter, dev)
 
-- 
2.43.0

