From 69083b35ffc25e87691a0d45e2c9657d85c1e4e9 Mon Sep 17 00:00:00 2001
From: saptarsis <saptarsis@nvidia.com>
Date: Thu, 6 Nov 2025 11:31:22 +0530
Subject: [PATCH] Changes to enable retries in mctp-i2c path

Changes enable 10 retries 2ms apart in the
MCTP_I2C_TX_FLOW_NONE & MCTP_I2C_TX_FLOW_EXISTING
part to mitigate EBUSY errors. This is in sync
with the userspace approach since MCTP bus
is bidirectional and retries can cover this.

Fiexs jira https://jirasw.nvidia.com/browse/DGXOPENBMC-21041

Signed-off-by: Saptarsi Saha <saptarsis@nvidia.com>
Upstream-Status: Pending [Not submitted to upstream yet]
---
 drivers/net/mctp/mctp-i2c.c | 34 ++++++++++++++++++++++++++++++++--
 1 file changed, 32 insertions(+), 2 deletions(-)

diff --git a/drivers/net/mctp/mctp-i2c.c b/drivers/net/mctp/mctp-i2c.c
index d2b3f5a59141..517bc2c382e0 100644
--- a/drivers/net/mctp/mctp-i2c.c
+++ b/drivers/net/mctp/mctp-i2c.c
@@ -22,6 +22,7 @@
 #include <linux/i2c.h>
 #include <linux/i2c-mux.h>
 #include <linux/if_arp.h>
+#include <linux/delay.h>
 #include <net/mctp.h>
 #include <net/mctpdevice.h>
 
@@ -37,6 +38,10 @@
 #define MCTP_I2C_TX_WORK_LEN 100
 /* Sufficient for 64kB at min mtu */
 #define MCTP_I2C_TX_QUEUE_LEN 1100
+/* Number of retries for I2C transfers */
+#define MCTP_I2C_TX_RETRY_COUNT 10
+/* Delay between I2C transfer retries in microseconds */
+#define MCTP_I2C_TX_RETRY_DELAY_US 2000
 
 #define MCTP_I2C_OF_PROP "mctp-controller"
 
@@ -478,6 +483,31 @@ static void mctp_i2c_invalidate_tx_flow(struct mctp_i2c_dev *midev,
 		mctp_i2c_unlock_nest(midev);
 }
 
+/* Helper function to perform I2C transfer with retries */
+static int mctp_i2c_transfer_with_retry(struct i2c_adapter *adapter,
+					struct i2c_msg *msg)
+{
+	int retry = MCTP_I2C_TX_RETRY_COUNT;
+	int rc;
+
+	do {
+		rc = __i2c_transfer(adapter, msg, 1);
+		if (rc < 0) {
+			/* Only retry for EBUSY errors */
+			if (rc == -EBUSY) {
+				if (retry > 0)
+					usleep_range(MCTP_I2C_TX_RETRY_DELAY_US,
+						     MCTP_I2C_TX_RETRY_DELAY_US + 100);
+			} else {
+				/* Non-retryable error */
+				break;
+			}
+		}
+	} while ((rc < 0) && (retry--));
+
+	return rc;
+}
+
 static void mctp_i2c_xmit(struct mctp_i2c_dev *midev, struct sk_buff *skb)
 {
 	struct net_device_stats *stats = &midev->ndev->stats;
@@ -521,7 +551,7 @@ static void mctp_i2c_xmit(struct mctp_i2c_dev *midev, struct sk_buff *skb)
 		/* no flow: full lock & unlock */
 		mctp_i2c_lock_nest(midev);
 		mctp_i2c_device_select(midev->client, midev);
-		rc = __i2c_transfer(midev->adapter, &msg, 1);
+		rc = mctp_i2c_transfer_with_retry(midev->adapter, &msg);
 		mctp_i2c_unlock_nest(midev);
 		break;
 
@@ -535,7 +565,7 @@ static void mctp_i2c_xmit(struct mctp_i2c_dev *midev, struct sk_buff *skb)
 
 	case MCTP_I2C_TX_FLOW_EXISTING:
 		/* existing flow: we already have the lock; just tx */
-		rc = __i2c_transfer(midev->adapter, &msg, 1);
+		rc = mctp_i2c_transfer_with_retry(midev->adapter, &msg);
 
 		/* on tx errors, the flow can no longer be considered valid */
 		if (rc)
-- 
2.43.0

