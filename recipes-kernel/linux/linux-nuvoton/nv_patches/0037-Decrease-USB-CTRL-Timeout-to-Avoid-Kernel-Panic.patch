From 11b30532a70a8e7b5a763819ca7aefacfad2ffda Mon Sep 17 00:00:00 2001
From: Kai Chen <tingkaic@nvidia.com>
Date: Wed, 19 Nov 2025 03:01:14 -0800
Subject: [PATCH] Decrease USB CTRL Timeout to Avoid Kernel Panic

Important:
This is a temporary fix to unblock factory testing.
It should not be pushed to the upstream, and should be reverted after
the async I2C xfer of CP2112 is implemented.

Issue:
When MCU is in the bad state, every HID transfer to CP2112 interface
will timeout after 5 seconds. Under this condition, the CP2112 driver
binding will take more than 3 min (5 sec * 39 xfer = 195 seconds) to
complete. Since the I2C bus has already been instantiated at the early
stage of the driver binding, users can access it through i2c-tools even
when the binding is not complete. However, the i2c-tools will wait the
lock since it's still held by the driver binding process. The wait time
exceeds hung_task_timeout (120 sec) and triggers kernel panic.

WAR:
change the timeout of the USB INTR MSG in usbhid from 5 sec to 500 msec.
The overall driver binding time is expected to be reduced to less than
30 sec and avoid the kernel panic.

Test: (platform is Parsec-BMC)
Given the MCU HID device is 0003:0955:CF11.0001:
on terminal 1
```
while true; do
    echo i2cget;
    i2cget -y 70 0x50 0x0;
done
```
on terminal 2
```
while true; do
    echo unbind;
    echo '0003:0955:CF11.0001' > /sys/bus/hid/drivers/cp2112/unbind ;
    echo bind;
    echo '0003:0955:CF11.0001' > /sys/bus/hid/drivers/cp2112/bind ;
done
```
No kernel panic should be observed.

Long term solution:
Current I2C xfer of CP2112 is synchronous. We can implement the async
I2C xfer with stricter timeout, so that it doesn't rely on the usbhid
config.

Fixes jira https://nvbugspro.nvidia.com/bug/5663355
Signed-off-by: Ting-Kai Chen <tingkaic@nvidia.com>
Upstream-Status: Pending [Not submitted to upstream yet]
---
 drivers/hid/usbhid/hid-core.c | 17 ++++++++++++++---
 1 file changed, 14 insertions(+), 3 deletions(-)

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 01625dbb28e8..47a4dfc83e51 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -43,6 +43,17 @@
 
 #define DRIVER_DESC "USB HID core driver"
 
+/*
+ * Timeout for control messages
+ * Decrease the timeout from default USB_CTRL_SET_TIMEOUT (5 sec).
+ * This change will impact all usbhid devices, but now only CP2112
+ * binds to this driver. External HID devices like mice and keyboards
+ * will not be affected since they're forwarded to host OS at
+ * chip-level.
+ */
+
+#define NV_USB_CTRL_SET_TIMEOUT	500  /* ms */
+
 /*
  * Module parameters.
  */
@@ -893,7 +904,7 @@ static int usbhid_get_raw_report(struct hid_device *hid,
 		USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
 		((report_type + 1) << 8) | report_number,
 		interface->desc.bInterfaceNumber, buf, count,
-		USB_CTRL_SET_TIMEOUT);
+		NV_USB_CTRL_SET_TIMEOUT);
 
 	/* count also the report id */
 	if (ret > 0 && skipped_report_id)
@@ -930,7 +941,7 @@ static int usbhid_set_raw_report(struct hid_device *hid, unsigned int reportnum,
 			USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,
 			((rtype + 1) << 8) | reportnum,
 			interface->desc.bInterfaceNumber, buf, count,
-			USB_CTRL_SET_TIMEOUT);
+			NV_USB_CTRL_SET_TIMEOUT);
 	/* count also the report id, if this was a numbered report. */
 	if (ret > 0 && skipped_report_id)
 		ret++;
@@ -956,7 +967,7 @@ static int usbhid_output_report(struct hid_device *hid, __u8 *buf, size_t count)
 
 	ret = usb_interrupt_msg(dev, usbhid->urbout->pipe,
 				buf, count, &actual_length,
-				USB_CTRL_SET_TIMEOUT);
+				NV_USB_CTRL_SET_TIMEOUT);
 	/* return the number of bytes transferred */
 	if (ret == 0) {
 		ret = actual_length;
-- 
2.43.0

