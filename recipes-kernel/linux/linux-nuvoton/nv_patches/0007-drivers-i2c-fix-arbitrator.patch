From bd2457490ae031affb17eaad1ae0193d9af9a0d3 Mon Sep 17 00:00:00 2001
From: "Radivoje (Ogi) Jovanovic" <rjovanovic@nvidia.com>
Date: Mon, 12 Dec 2022 10:05:08 -0800
Subject: [PATCH] drivers: i2c: fix arbitrator

timers cannot be used since the driver is accessing i2c bus
and timer cannot sleep since it is soft irq context.
use work queue instead.
changed dts file with the correct information.
fixed i2c message to new register layout

Signed-off-by: Radivoje (Ogi) Jovanovic <rjovanovic@nvidia.com>
fixes JIRA https://jirasw.nvidia.com/browse/DGXOPENBMC-6184
Upstream-Status: Pending [Not submitted to upstream yet]
---
 drivers/i2c/muxes/i2c-arb-gpio-challenge.c | 207 ++++++++++++++++++++-
 1 file changed, 206 insertions(+), 1 deletion(-)

diff --git a/drivers/i2c/muxes/i2c-arb-gpio-challenge.c b/drivers/i2c/muxes/i2c-arb-gpio-challenge.c
index 7aa6e795d833..69da27657062 100644
--- a/drivers/i2c/muxes/i2c-arb-gpio-challenge.c
+++ b/drivers/i2c/muxes/i2c-arb-gpio-challenge.c
@@ -14,6 +14,11 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 
+#if CONFIG_DRAGON_CHASSIS
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/spinlock.h>
+#endif //CONFIG_DRAGON_CHASSIS
 
 /**
  * struct i2c_arbitrator_data - Driver data for I2C arbitrator
@@ -31,6 +36,16 @@ struct i2c_arbitrator_data {
 	unsigned int slew_delay_us;
 	unsigned int wait_retry_us;
 	unsigned int wait_free_us;
+	struct timer_list timer;
+	struct i2c_mux_core *muxc;
+#if CONFIG_DRAGON_CHASSIS
+	struct i2c_adapter *cpld_access;
+	u8 cpld_address;
+	bool bus_locked;
+	struct workqueue_struct *wq;
+	struct delayed_work dwork;
+	spinlock_t bus_locked_spin;
+#endif //CONFIG_DRAGON_CHASSIS
 };
 
 
@@ -56,7 +71,7 @@ static int i2c_arbitrator_select(struct i2c_mux_core *muxc, u32 chan)
 		while (time_before(jiffies, stop_retry)) {
 			int gpio_val = gpiod_get_value(arb->their_gpio);
 
-			if (!gpio_val) {
+			if (gpio_val) {
 				/* We got it, so return */
 				return 0;
 			}
@@ -93,6 +108,161 @@ static int i2c_arbitrator_deselect(struct i2c_mux_core *muxc, u32 chan)
 	return 0;
 }
 
+#if CONFIG_DRAGON_CHASSIS
+static ssize_t gpio_our_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_mux_core *muxc = i2c_get_clientdata(client);
+	const struct i2c_arbitrator_data *arb = i2c_mux_priv(muxc);
+	int gpio_val = -1;
+
+	gpio_val = gpiod_get_value(arb->our_gpio);
+
+	return sprintf(buf, "%d\n", gpio_val);
+}
+static DEVICE_ATTR_RO(gpio_our);
+
+static ssize_t gpio_their_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_mux_core *muxc = i2c_get_clientdata(client);
+	const struct i2c_arbitrator_data *arb = i2c_mux_priv(muxc);
+	int gpio_val = -1;
+
+	gpio_val = gpiod_get_value(arb->their_gpio);
+
+	return sprintf(buf, "%d\n", gpio_val);
+}
+static DEVICE_ATTR_RO(gpio_their);
+
+static ssize_t cpld_refresh_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_mux_core *muxc = i2c_get_clientdata(client);
+	const struct i2c_arbitrator_data *arb = i2c_mux_priv(muxc);
+	int gpio_val = -1;
+
+	if (!IS_ERR(arb->cpld_refresh))
+		gpio_val = gpiod_get_value(arb->cpld_refresh);
+
+	return sprintf(buf, "%d\n", gpio_val);
+}
+static DEVICE_ATTR_RO(cpld_refresh);
+
+static ssize_t arb_state_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_mux_core *muxc = i2c_get_clientdata(client);
+	const struct i2c_arbitrator_data *arb = i2c_mux_priv(muxc);
+
+	int gpio_val = gpiod_get_value(arb->their_gpio);
+
+	if (!IS_ERR(arb->cpld_refresh)) {
+		if (gpiod_get_value(arb->cpld_refresh))
+			return -EBUSY;
+	}
+
+	return sprintf(buf, "%d\n", gpio_val);
+}
+
+static ssize_t arb_state_store(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_mux_core *muxc = i2c_get_clientdata(client);
+	struct i2c_arbitrator_data *arb = i2c_mux_priv(muxc);
+	int val;
+	int ret;
+
+	ret = kstrtoint(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	if (!val) {
+		spin_lock(&arb->bus_locked_spin);
+		arb->bus_locked = false;
+		spin_unlock(&arb->bus_locked_spin);
+		cancel_delayed_work_sync(&arb->dwork);
+		i2c_arbitrator_deselect(muxc, 0);
+	} else {
+		ret = i2c_arbitrator_select(muxc, 0);
+		if (ret < 0)
+			return ret;
+		spin_lock(&arb->bus_locked_spin);
+		arb->bus_locked = true;
+		spin_unlock(&arb->bus_locked_spin);
+		queue_delayed_work(arb->wq, &arb->dwork, 0);
+	}
+	return count;
+}
+static DEVICE_ATTR_RW(arb_state);
+
+static void pet_cpld_register(struct work_struct *work)
+{
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct i2c_arbitrator_data *arb = container_of(dwork, struct i2c_arbitrator_data, dwork);
+	struct i2c_mux_core *muxc = arb->muxc;
+	int gpio_val;
+	u8 out_buf0[2];
+	u8 out_buf1[2];
+	struct i2c_msg msgs[] = {
+		{
+			.addr = arb->cpld_address,
+			.flags = 0,
+			.len = 2,
+			.buf = out_buf0,
+		},
+		{
+			.addr = arb->cpld_address,
+			.flags = 0,
+			.len = 2,
+			.buf = out_buf1,
+		}
+	};
+
+	out_buf0[0] = 16;
+	out_buf0[1] = 0x20;
+	out_buf1[0] = 16;
+	out_buf1[1] = 0x10;
+
+	gpio_val = gpiod_get_value(arb->their_gpio);
+
+	if (gpio_val)
+	{
+		if (i2c_transfer(arb->cpld_access, msgs, 2) != 2) {
+			dev_err(muxc->dev, "Could not access cpld to pet the watchdog\n");
+			spin_lock(&arb->bus_locked_spin);
+			arb->bus_locked = false;
+			spin_unlock(&arb->bus_locked_spin);
+			i2c_arbitrator_deselect(muxc, 0);
+
+		}
+		else
+			queue_delayed_work(arb->wq, &arb->dwork, msecs_to_jiffies(1000));
+	}
+	else
+	{
+			spin_lock(&arb->bus_locked_spin);
+			arb->bus_locked = false;
+			spin_unlock(&arb->bus_locked_spin);
+			i2c_arbitrator_deselect(muxc, 0);
+			dev_err(muxc->dev, "Arbitration was unexpectedly dropped.\n");
+	}
+}
+#endif //CONFIG_DRAGON_CHASSIS
+
 static int i2c_arbitrator_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -153,6 +323,32 @@ static int i2c_arbitrator_probe(struct platform_device *pdev)
 	if (of_property_read_u32(np, "wait-free-us", &arb->wait_free_us))
 		arb->wait_free_us = 50000;
 
+#if CONFIG_DRAGON_CHASSIS
+	/* Find our cpld i2c bus */
+	cpld_np = of_parse_phandle(np, "i2c-cpld", 0);
+	if (!cpld_np) {
+		dev_err(dev, "Cannot parse i2c-cpld\n");
+		return -EINVAL;
+	}
+	arb->cpld_access = of_get_i2c_adapter_by_node(cpld_np);
+	of_node_put(cpld_np);
+	if (!arb->cpld_access) {
+		dev_err(dev, "Cannot find cpld bus\n");
+		return -EPROBE_DEFER;
+	}
+	if (of_property_read_u8(np, "cpld-address", &arb->cpld_address)) {
+		dev_err(dev, "cpld-address must be present in dts\n");
+		return -EINVAL;
+	}
+
+	arb->wq = create_singlethread_workqueue("i2c_arb_events");
+	if (!arb->wq) {
+		dev_err(dev, "Cannot create work queue\n");
+		return -ENOMEM;
+	}
+	spin_lock_init(&arb->bus_locked_spin);
+#endif //CONFIG_DRAGON_CHASSIS
+
 	/* Find our parent */
 	parent_np = of_parse_phandle(np, "i2c-parent", 0);
 	if (!parent_np) {
@@ -171,6 +367,15 @@ static int i2c_arbitrator_probe(struct platform_device *pdev)
 	if (ret)
 		i2c_put_adapter(muxc->parent);
 
+#if CONFIG_DRAGON_CHASSIS
+	INIT_DELAYED_WORK(&arb->dwork, pet_cpld_register);
+	device_create_file(dev, &dev_attr_arb_state);
+	device_create_file(dev, &dev_attr_cpld_refresh);
+	device_create_file(dev, &dev_attr_gpio_our);
+	device_create_file(dev, &dev_attr_gpio_their);
+	arb->bus_locked = false;
+#endif //CONFIG_DRAGON_CHASSIS
+
 	return ret;
 }
 
-- 
2.43.0

