Upstream-Status: Pending [Not submitted to upstream yet]

From 5b2c19efc2cfe86a202467646cdec6017536d194 Mon Sep 17 00:00:00 2001
From: Mia Lin <mylin1@nuvoton.com>
Date: Fri, 3 Oct 2025 08:03:00 +0000
Subject: [PATCH] rtc: nuvoton: Add intrusion detection and timestamp recording

Merged:
- driver: rtc: add intrusion event detection
- driver: rtc: Add record intrusion and vcc drop timestamps when bmc boots up.

Signed-off-by: Mia Lin <mylin1@nuvoton.com>
---
 drivers/rtc/rtc-nct3018y.c | 180 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 176 insertions(+), 4 deletions(-)

diff --git a/drivers/rtc/rtc-nct3018y.c b/drivers/rtc/rtc-nct3018y.c
index 76c5f464b2da..6f4f91faf0e2 100644
--- a/drivers/rtc/rtc-nct3018y.c
+++ b/drivers/rtc/rtc-nct3018y.c
@@ -24,6 +24,9 @@
 #define NCT3018Y_REG_ST		0x0B /* status */
 #define NCT3018Y_REG_CLKO	0x0C /* clock out */
 #define NCT3018Y_REG_PART	0x21 /* part info */
+#define NCT3018Y_REG_INTR_CTRL	0x12 /* intrusion control */
+#define NCT3018Y_REG_INTR_TS_SC	0x13 /* intrusion seconds */
+#define NCT3018Y_REG_VCC_DROP_TS_SC	0x19 /* intrusion seconds */
 
 #define NCT3018Y_BIT_AF		BIT(7)
 #define NCT3018Y_BIT_ST		BIT(7)
@@ -34,6 +37,8 @@
 #define NCT3018Y_BIT_OFIE	BIT(2)
 #define NCT3018Y_BIT_CIE	BIT(1)
 #define NCT3018Y_BIT_TWO	BIT(0)
+#define NCT3018Y_BIT_INTRF	BIT(1)
+#define NCT3018Y_BIT_INTRIE	BIT(0)
 
 #define NCT3018Y_REG_BAT_MASK		0x07
 #define NCT3018Y_REG_CLKO_F_MASK	0x03 /* frequenc mask */
@@ -47,6 +52,8 @@ struct nct3018y {
 #ifdef CONFIG_COMMON_CLK
 	struct clk_hw clkout_hw;
 #endif
+	struct rtc_time *intrusion_timestamp;
+	struct rtc_time *vcc_drop_timestamp;
 };
 
 static int nct3018y_set_alarm_mode(struct i2c_client *client, bool on)
@@ -55,7 +62,7 @@ static int nct3018y_set_alarm_mode(struct i2c_client *client, bool on)
 
 	dev_dbg(&client->dev, "%s:on:%d\n", __func__, on);
 
-	flags =  i2c_smbus_read_byte_data(client, NCT3018Y_REG_CTRL);
+	flags = i2c_smbus_read_byte_data(client, NCT3018Y_REG_CTRL);
 	if (flags < 0) {
 		dev_dbg(&client->dev,
 			"Failed to read NCT3018Y_REG_CTRL\n");
@@ -118,6 +125,135 @@ static int nct3018y_get_alarm_mode(struct i2c_client *client, unsigned char *ala
 	return 0;
 }
 
+static int nct3018y_set_intrusion_mode(struct i2c_client *client, bool on)
+{
+	int err, flags;
+
+	dev_dbg(&client->dev, "%s:on:%d\n", __func__, on);
+
+	flags = i2c_smbus_read_byte_data(client, NCT3018Y_REG_INTR_CTRL);
+	if (flags < 0) {
+		dev_dbg(&client->dev,
+			"Failed to read NCT3018Y_REG_INTR_CTRL\n");
+		return flags;
+	}
+
+	/* Clear intrusion flag first. */
+	flags &= ~NCT3018Y_BIT_INTRF; /* This bit can be cleared only when INTRUDER# is high */
+	err = i2c_smbus_write_byte_data(client, NCT3018Y_REG_INTR_CTRL, flags);
+	if (err < 0) {
+		dev_dbg(&client->dev, "Unable to write NCT3018Y_REG_INTR_CTRL\n");
+		return err;
+	}
+
+	if (on)
+		flags |= NCT3018Y_BIT_INTRIE;
+	else
+		flags &= ~NCT3018Y_BIT_INTRIE;
+
+	err = i2c_smbus_write_byte_data(client, NCT3018Y_REG_INTR_CTRL, flags);
+	if (err < 0) {
+		dev_dbg(&client->dev, "Unable to write NCT3018Y_REG_INTR_CTRL\n");
+		return err;
+	}
+
+	return 0;
+}
+
+static int nct3018y_get_intrusion_mode(struct i2c_client *client, unsigned char *enable,
+				       unsigned char *flag)
+{
+	int ret = 0;
+	int control;
+
+	if (enable) {
+		dev_dbg(&client->dev, "%s:NCT3018Y_REG_INTR_CTRL\n", __func__);
+		control =  i2c_smbus_read_byte_data(client, NCT3018Y_REG_INTR_CTRL);
+		if (control < 0)
+			return control;
+		*enable = control & NCT3018Y_BIT_INTRIE;
+		*flag = control & NCT3018Y_BIT_INTRF;
+	}
+
+	dev_dbg(&client->dev, "%s:enable:%x flag:%x\n",
+		__func__, *enable, *flag);
+	return ret;
+}
+
+static int nct3018y_get_intrusion_timestamp(struct i2c_client *client, struct rtc_time *tm)
+{
+	int ret = 0;
+	unsigned char buf[6];
+
+	ret = i2c_smbus_read_i2c_block_data(client, NCT3018Y_REG_INTR_TS_SC, sizeof(buf), buf);
+	if (ret < 0)
+		return ret;
+
+	tm->tm_sec = bcd2bin(buf[0] & 0x7F);
+	tm->tm_min = bcd2bin(buf[1] & 0x7F);
+	tm->tm_hour = bcd2bin(buf[2] & 0xFF);
+	tm->tm_mday = bcd2bin(buf[3] & 0x3F);
+	tm->tm_mon = bcd2bin(buf[4] & 0x1F) - 1;
+	tm->tm_year = bcd2bin(buf[5]) + 100;
+
+	dev_dbg(&client->dev, "%s:s=%d m=%d, hr=%d\n",
+		__func__, tm->tm_sec, tm->tm_min,
+		tm->tm_hour);
+	return 0;
+}
+
+static int nct3018y_get_vcc_drop_timestamp(struct i2c_client *client, struct rtc_time *tm)
+{
+	int ret = 0;
+	unsigned char buf[6];
+
+	ret = i2c_smbus_read_i2c_block_data(client, NCT3018Y_REG_VCC_DROP_TS_SC, sizeof(buf), buf);
+	if (ret < 0)
+		return ret;
+
+	tm->tm_sec = bcd2bin(buf[0] & 0x7F);
+	tm->tm_min = bcd2bin(buf[1] & 0x7F);
+	tm->tm_hour = bcd2bin(buf[2] & 0xFF);
+	tm->tm_mday = bcd2bin(buf[3] & 0x3F);
+	tm->tm_mon = bcd2bin(buf[4] & 0x1F) - 1;
+	tm->tm_year = bcd2bin(buf[5]) + 100;
+
+	dev_dbg(&client->dev, "%s:s=%d m=%d, hr=%d\n",
+		__func__, tm->tm_sec, tm->tm_min,
+		tm->tm_hour);
+	return 0;
+}
+
+static ssize_t intrusion_timestamp_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct nct3018y *nct3018y = dev_get_drvdata(dev->parent);
+
+	return sprintf(buf, "%ptR UTC\n", nct3018y->intrusion_timestamp);
+};
+
+static DEVICE_ATTR_RO(intrusion_timestamp);
+
+static ssize_t vcc_drop_timestamp_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct nct3018y *nct3018y = dev_get_drvdata(dev->parent);
+
+	return sprintf(buf, "%ptR UTC\n", nct3018y->vcc_drop_timestamp);
+};
+
+static DEVICE_ATTR_RO(vcc_drop_timestamp);
+
+static struct attribute *nct3018y_attrs[] = {
+	&dev_attr_intrusion_timestamp.attr,
+	&dev_attr_vcc_drop_timestamp.attr,
+	NULL
+};
+
+static const struct attribute_group nct3018y_attr_group = {
+	.attrs	= nct3018y_attrs,
+};
+
 static irqreturn_t nct3018y_irq(int irq, void *dev_id)
 {
 	struct nct3018y *nct3018y = i2c_get_clientdata(dev_id);
@@ -125,22 +261,34 @@ static irqreturn_t nct3018y_irq(int irq, void *dev_id)
 	int err;
 	unsigned char alarm_flag;
 	unsigned char alarm_enable;
+	unsigned char intrusion_flag, intrusion_enable;
 
 	dev_dbg(&client->dev, "%s:irq:%d\n", __func__, irq);
 	err = nct3018y_get_alarm_mode(nct3018y->client, &alarm_enable, &alarm_flag);
 	if (err)
 		return IRQ_NONE;
 
-	if (alarm_flag) {
+	if (alarm_enable && alarm_flag) {
 		dev_dbg(&client->dev, "%s:alarm flag:%x\n",
 			__func__, alarm_flag);
 		rtc_update_irq(nct3018y->rtc, 1, RTC_IRQF | RTC_AF);
 		nct3018y_set_alarm_mode(nct3018y->client, 0);
 		dev_dbg(&client->dev, "%s:IRQ_HANDLED\n", __func__);
-		return IRQ_HANDLED;
 	}
 
-	return IRQ_NONE;
+	err = nct3018y_get_intrusion_mode(nct3018y->client, &intrusion_enable, &intrusion_flag);
+	if (err < 0)
+		return IRQ_NONE;
+	if (intrusion_enable && intrusion_flag) {
+		/* Get the timestamp of intrusion event */
+		err = nct3018y_get_intrusion_timestamp(nct3018y->client, nct3018y->intrusion_timestamp);
+		if (err < 0)
+			return IRQ_NONE;
+		nct3018y_set_intrusion_mode(nct3018y->client, 1);
+		sysfs_notify(&nct3018y->rtc->dev.kobj, NULL, dev_attr_intrusion_timestamp.attr.name);
+	}
+
+	return IRQ_HANDLED;
 }
 
 /*
@@ -490,6 +638,7 @@ static int nct3018y_probe(struct i2c_client *client)
 {
 	struct nct3018y *nct3018y;
 	int err, flags;
+	u32 intrusion_en;
 
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C |
 				     I2C_FUNC_SMBUS_BYTE |
@@ -558,6 +707,29 @@ static int nct3018y_probe(struct i2c_client *client)
 		clear_bit(RTC_FEATURE_ALARM, nct3018y->rtc->features);
 	}
 
+	/* Create sysfs file */
+	err = rtc_add_group(nct3018y->rtc, &nct3018y_attr_group);
+	if (err)
+		return err;
+
+	nct3018y->intrusion_timestamp = devm_kzalloc(&client->dev, sizeof(struct rtc_time), GFP_KERNEL);
+	nct3018y->vcc_drop_timestamp = devm_kzalloc(&client->dev, sizeof(struct rtc_time), GFP_KERNEL);
+
+	/* Record intrusion timestamp */
+	err = nct3018y_get_intrusion_timestamp(client, nct3018y->intrusion_timestamp);
+	if (err < 0)
+		dev_dbg(&client->dev, "%s: read error\n", __func__);
+
+	/* Record Vcc drop timestamp */
+	err = nct3018y_get_vcc_drop_timestamp(client, nct3018y->vcc_drop_timestamp);
+	if (err < 0)
+		dev_dbg(&client->dev, "%s: read error\n", __func__);
+
+	/* Enable intrusion interrupt */
+	of_property_read_u32(client->dev.of_node, "intrusion-enable", &intrusion_en);
+	dev_dbg(&client->dev, "%s(%d) intrusion_en=%d\n", __func__, __LINE__, intrusion_en);
+	nct3018y_set_intrusion_mode(nct3018y->client, intrusion_en);
+
 #ifdef CONFIG_COMMON_CLK
 	/* register clk in common clk framework */
 	nct3018y_clkout_register_clk(nct3018y);
-- 
2.43.0

