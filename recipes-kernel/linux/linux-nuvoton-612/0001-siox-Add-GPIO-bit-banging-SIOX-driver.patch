From 488a0028a706748d1da0473d0e6a2d03b662129e Mon Sep 17 00:00:00 2001
From: Marvin Lin <milkfafa@gmail.com>
Date: Fri, 1 Aug 2025 09:45:49 +0800
Subject: [PATCH] siox: Support GPIO bit-banging SIOX driver

Signed-off-by: Marvin Lin <milkfafa@gmail.com>
---
 drivers/gpio/gpio-siox.c     | 168 ++++++++++++++---------------------
 drivers/siox/siox-bus-gpio.c |  76 ++++++++++------
 drivers/siox/siox-core.c     | 159 +++++++++------------------------
 drivers/siox/siox.h          |   2 +-
 4 files changed, 156 insertions(+), 249 deletions(-)

diff --git a/drivers/gpio/gpio-siox.c b/drivers/gpio/gpio-siox.c
index 051bc99bdfb2..4481a592a0b8 100644
--- a/drivers/gpio/gpio-siox.c
+++ b/drivers/gpio/gpio-siox.c
@@ -8,16 +8,20 @@
 #include <linux/gpio/driver.h>
 #include <linux/of.h>
 
+#define BANK_BITS		8
+#define BANK_NUM		16
+#define GPIO_BANK(offset)	((offset) / (BANK_BITS * 2))
+#define BIT_MASK(offset)	(1 << (((offset) / 2) % BANK_BITS))
+
 struct gpio_siox_ddata {
 	struct gpio_chip gchip;
 	struct mutex lock;
-	u8 setdata[1];
-	u8 getdata[3];
+	u8 in_bank[BANK_NUM];
+	u8 out_bank[BANK_NUM];
 
 	raw_spinlock_t irqlock;
-	u32 irq_enable;
-	u32 irq_status;
-	u32 irq_type[20];
+	u8 irq_status[BANK_NUM];
+	u32 irq_type[BANK_BITS * BANK_NUM];
 };
 
 /*
@@ -29,7 +33,7 @@ static int gpio_siox_set_data(struct siox_device *sdevice, u8 status, u8 buf[])
 	struct gpio_siox_ddata *ddata = dev_get_drvdata(&sdevice->dev);
 
 	mutex_lock(&ddata->lock);
-	buf[0] = ddata->setdata[0];
+	memcpy(buf, ddata->out_bank, sizeof(ddata->out_bank));
 	mutex_unlock(&ddata->lock);
 
 	return 0;
@@ -38,104 +42,72 @@ static int gpio_siox_set_data(struct siox_device *sdevice, u8 status, u8 buf[])
 static int gpio_siox_get_data(struct siox_device *sdevice, const u8 buf[])
 {
 	struct gpio_siox_ddata *ddata = dev_get_drvdata(&sdevice->dev);
-	size_t offset;
-	u32 trigger;
+	size_t i, j;
+	struct irq_domain *irqdomain;
+	unsigned int irq, gpiolevel, prev_level;
 
 	mutex_lock(&ddata->lock);
-
 	raw_spin_lock_irq(&ddata->irqlock);
 
-	for (offset = 0; offset < 12; ++offset) {
-		unsigned int bitpos = 11 - offset;
-		unsigned int gpiolevel = buf[bitpos / 8] & (1 << bitpos % 8);
-		unsigned int prev_level =
-			ddata->getdata[bitpos / 8] & (1 << (bitpos % 8));
-		u32 irq_type = ddata->irq_type[offset];
-
-		if (gpiolevel) {
-			if ((irq_type & IRQ_TYPE_LEVEL_HIGH) ||
-			    ((irq_type & IRQ_TYPE_EDGE_RISING) && !prev_level))
-				ddata->irq_status |= 1 << offset;
-		} else {
-			if ((irq_type & IRQ_TYPE_LEVEL_LOW) ||
-			    ((irq_type & IRQ_TYPE_EDGE_FALLING) && prev_level))
-				ddata->irq_status |= 1 << offset;
+	for (i = 0; i < BANK_NUM; i++) {
+		for (j = 0; j < BANK_BITS; j++) {
+			gpiolevel = buf[i] & (1 << j);
+			prev_level = ddata->in_bank[i] & (1 << j);
+			u32 irq_type = ddata->irq_type[BANK_BITS * i + j];
+
+			if (gpiolevel) {
+				if ((irq_type & IRQ_TYPE_LEVEL_HIGH) ||
+				    ((irq_type & IRQ_TYPE_EDGE_RISING) && !prev_level))
+					ddata->irq_status[i] |= (1 << j);
+			} else {
+				if ((irq_type & IRQ_TYPE_LEVEL_LOW) ||
+				    ((irq_type & IRQ_TYPE_EDGE_FALLING) && prev_level))
+					ddata->irq_status[i] |= (1 << j);
+			}
 		}
 	}
 
-	trigger = ddata->irq_status & ddata->irq_enable;
-
 	raw_spin_unlock_irq(&ddata->irqlock);
-
-	ddata->getdata[0] = buf[0];
-	ddata->getdata[1] = buf[1];
-	ddata->getdata[2] = buf[2];
-
+	memcpy(ddata->in_bank, buf, sizeof(ddata->in_bank));
 	mutex_unlock(&ddata->lock);
 
-	for (offset = 0; offset < 12; ++offset) {
-		if (trigger & (1 << offset)) {
-			struct irq_domain *irqdomain = ddata->gchip.irq.domain;
-			unsigned int irq = irq_find_mapping(irqdomain, offset);
-
-			/*
-			 * Conceptually handle_nested_irq should call the flow
-			 * handler of the irq chip. But it doesn't, so we have
-			 * to clean the irq_status here.
-			 */
-			raw_spin_lock_irq(&ddata->irqlock);
-			ddata->irq_status &= ~(1 << offset);
-			raw_spin_unlock_irq(&ddata->irqlock);
-
-			handle_nested_irq(irq);
+	for (i = 0; i < BANK_NUM; i++) {
+		for (j = 0; j < BANK_BITS; j++) {
+			if (ddata->irq_status[i] & (1 << j)) {
+				irqdomain = ddata->gchip.irq.domain;
+				irq = irq_find_mapping(irqdomain, i * BANK_BITS * 2 + j * 2);
+
+				raw_spin_lock_irq(&ddata->irqlock);
+				generic_handle_irq(irq);
+				ddata->irq_status[i] &= ~(1 << j);
+				raw_spin_unlock_irq(&ddata->irqlock);
+			}
 		}
 	}
 
 	return 0;
 }
 
-static void gpio_siox_irq_ack(struct irq_data *d)
-{
-	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
-	struct gpio_siox_ddata *ddata = gpiochip_get_data(gc);
+static void gpio_siox_irq_ack(struct irq_data *d) {}
+static void gpio_siox_irq_mask(struct irq_data *d) {}
+static void gpio_siox_irq_unmask(struct irq_data *d) {}
 
-	raw_spin_lock(&ddata->irqlock);
-	ddata->irq_status &= ~(1 << d->hwirq);
-	raw_spin_unlock(&ddata->irqlock);
-}
-
-static void gpio_siox_irq_mask(struct irq_data *d)
+static int gpio_siox_irq_set_type(struct irq_data *d, u32 type)
 {
 	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
 	struct gpio_siox_ddata *ddata = gpiochip_get_data(gc);
 
 	raw_spin_lock(&ddata->irqlock);
-	ddata->irq_enable &= ~(1 << d->hwirq);
+	/* d->hwirq is equal to the pin offset of gpio_chip */
+	ddata->irq_type[d->hwirq / 2] = type;
 	raw_spin_unlock(&ddata->irqlock);
-	gpiochip_disable_irq(gc, irqd_to_hwirq(d));
-}
 
-static void gpio_siox_irq_unmask(struct irq_data *d)
-{
-	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
-	struct gpio_siox_ddata *ddata = gpiochip_get_data(gc);
-
-	gpiochip_enable_irq(gc, irqd_to_hwirq(d));
-	raw_spin_lock(&ddata->irqlock);
-	ddata->irq_enable |= 1 << d->hwirq;
-	raw_spin_unlock(&ddata->irqlock);
+	return 0;
 }
 
-static int gpio_siox_irq_set_type(struct irq_data *d, u32 type)
+static bool gpio_siox_is_input(unsigned int offset)
 {
-	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
-	struct gpio_siox_ddata *ddata = gpiochip_get_data(gc);
-
-	raw_spin_lock(&ddata->irqlock);
-	ddata->irq_type[d->hwirq] = type;
-	raw_spin_unlock(&ddata->irqlock);
-
-	return 0;
+	return !(offset % 2);
 }
 
 static int gpio_siox_get(struct gpio_chip *chip, unsigned int offset)
@@ -145,15 +117,10 @@ static int gpio_siox_get(struct gpio_chip *chip, unsigned int offset)
 
 	mutex_lock(&ddata->lock);
 
-	if (offset >= 12) {
-		unsigned int bitpos = 19 - offset;
-
-		ret = ddata->setdata[0] & (1 << bitpos);
-	} else {
-		unsigned int bitpos = 11 - offset;
-
-		ret = ddata->getdata[bitpos / 8] & (1 << (bitpos % 8));
-	}
+	if (gpio_siox_is_input(offset))
+		ret = ddata->in_bank[GPIO_BANK(offset)] & BIT_MASK(offset);
+	else
+		ret = ddata->out_bank[GPIO_BANK(offset)] & BIT_MASK(offset);
 
 	mutex_unlock(&ddata->lock);
 
@@ -164,14 +131,13 @@ static void gpio_siox_set(struct gpio_chip *chip,
 			  unsigned int offset, int value)
 {
 	struct gpio_siox_ddata *ddata = gpiochip_get_data(chip);
-	u8 mask = 1 << (19 - offset);
 
 	mutex_lock(&ddata->lock);
 
 	if (value)
-		ddata->setdata[0] |= mask;
+		ddata->out_bank[GPIO_BANK(offset)] |= BIT_MASK(offset);
 	else
-		ddata->setdata[0] &= ~mask;
+		ddata->out_bank[GPIO_BANK(offset)] &= ~BIT_MASK(offset);
 
 	mutex_unlock(&ddata->lock);
 }
@@ -179,16 +145,13 @@ static void gpio_siox_set(struct gpio_chip *chip,
 static int gpio_siox_direction_input(struct gpio_chip *chip,
 				     unsigned int offset)
 {
-	if (offset >= 12)
-		return -EINVAL;
-
-	return 0;
+	return gpio_siox_is_input(offset) ? 0 : -EINVAL;
 }
 
 static int gpio_siox_direction_output(struct gpio_chip *chip,
 				      unsigned int offset, int value)
 {
-	if (offset < 12)
+	if (gpio_siox_is_input(offset))
 		return -EINVAL;
 
 	gpio_siox_set(chip, offset, value);
@@ -197,10 +160,7 @@ static int gpio_siox_direction_output(struct gpio_chip *chip,
 
 static int gpio_siox_get_direction(struct gpio_chip *chip, unsigned int offset)
 {
-	if (offset < 12)
-		return GPIO_LINE_DIRECTION_IN;
-	else
-		return GPIO_LINE_DIRECTION_OUT;
+	return !!gpio_siox_is_input(offset);
 }
 
 static const struct irq_chip gpio_siox_irq_chip = {
@@ -209,8 +169,7 @@ static const struct irq_chip gpio_siox_irq_chip = {
 	.irq_mask = gpio_siox_irq_mask,
 	.irq_unmask = gpio_siox_irq_unmask,
 	.irq_set_type = gpio_siox_irq_set_type,
-	.flags = IRQCHIP_IMMUTABLE,
-	GPIOCHIP_IRQ_RESOURCE_HELPERS,
+	.flags = IRQCHIP_SKIP_SET_WAKE | IRQCHIP_IMMUTABLE,
 };
 
 static int gpio_siox_probe(struct siox_device *sdevice)
@@ -225,6 +184,7 @@ static int gpio_siox_probe(struct siox_device *sdevice)
 	if (!ddata)
 		return -ENOMEM;
 
+	memset(ddata->in_bank, 0, sizeof(ddata->in_bank));
 	dev_set_drvdata(dev, ddata);
 
 	mutex_init(&ddata->lock);
@@ -240,13 +200,15 @@ static int gpio_siox_probe(struct siox_device *sdevice)
 	gc->direction_input = gpio_siox_direction_input;
 	gc->direction_output = gpio_siox_direction_output;
 	gc->get_direction = gpio_siox_get_direction;
-	gc->ngpio = 20;
+	gc->ngpio = BANK_NUM * BANK_BITS * 2; /* in_bank & out_bank */
 
 	girq = &gc->irq;
 	gpio_irq_chip_set_chip(girq, &gpio_siox_irq_chip);
+	girq->parent_handler = NULL;
+	girq->num_parents = 0;
+	girq->parents = NULL;
 	girq->default_type = IRQ_TYPE_NONE;
-	girq->handler = handle_level_irq;
-	girq->threaded = true;
+	girq->handler = handle_simple_irq;
 
 	ret = devm_gpiochip_add_data(dev, gc, ddata);
 	if (ret)
diff --git a/drivers/siox/siox-bus-gpio.c b/drivers/siox/siox-bus-gpio.c
index d6f936464063..3b3fa547092b 100644
--- a/drivers/siox/siox-bus-gpio.c
+++ b/drivers/siox/siox-bus-gpio.c
@@ -19,58 +19,74 @@ struct siox_gpio_ddata {
 	struct gpio_desc *dout;
 	struct gpio_desc *dclk;
 	struct gpio_desc *dld;
+
+	/* connect to din for loopback test */
+	struct gpio_desc *dlb;
 };
 
-static unsigned int siox_clkhigh_ns = 1000;
-static unsigned int siox_loadhigh_ns;
-static unsigned int siox_bytegap_ns;
+static unsigned int siox_clkhigh_ns = 500;
 
 static int siox_gpio_pushpull(struct siox_master *smaster,
 			      size_t setbuf_len, const u8 setbuf[],
-			      size_t getbuf_len, u8 getbuf[])
+			      size_t getbuf_len, u8 getbuf[], u8 lb_pattern)
 {
 	struct siox_gpio_ddata *ddata = siox_master_get_devdata(smaster);
-	size_t i;
-	size_t cycles = max(setbuf_len, getbuf_len);
+	int i, j;
+	int cycles = max(setbuf_len, getbuf_len);
 
 	/* reset data and clock */
 	gpiod_set_value_cansleep(ddata->dout, 0);
 	gpiod_set_value_cansleep(ddata->dclk, 0);
-
 	gpiod_set_value_cansleep(ddata->dld, 1);
-	ndelay(siox_loadhigh_ns);
+	if (ddata->dlb)
+		gpiod_set_value_cansleep(ddata->dlb, 0);
+
+	/*
+	 * SGPMLD: pull low at the first and last clock
+	 *  SGPMO: transmit MSB & highest bit first (transmit on clock falling edge)
+	 *  SGPMI: receive LSB & highest bit first (sample on clock falling edge)
+	 */
+
 	gpiod_set_value_cansleep(ddata->dld, 0);
 
-	for (i = 0; i < cycles; ++i) {
+	for (i = (cycles - 1); i >= 0; i--) {
 		u8 set = 0, get = 0;
-		size_t j;
 
-		if (i >= cycles - setbuf_len)
-			set = setbuf[i - (cycles - setbuf_len)];
-
-		for (j = 0; j < 8; ++j) {
-			get <<= 1;
-			if (gpiod_get_value_cansleep(ddata->din))
-				get |= 1;
+		set = setbuf[i];
+		for (j = 7; j >= 0; j--) {
+			gpiod_set_value_cansleep(ddata->dclk, 1);
 
-			/* DOUT is logically inverted */
-			gpiod_set_value_cansleep(ddata->dout, !(set & 0x80));
-			set <<= 1;
+			/* send loopback pattern on clock rising edge */
+			if (ddata->dlb)
+				gpiod_set_value_cansleep(ddata->dlb,
+							 (lb_pattern >> j) & 1);
 
-			gpiod_set_value_cansleep(ddata->dclk, 1);
 			ndelay(siox_clkhigh_ns);
 			gpiod_set_value_cansleep(ddata->dclk, 0);
+
+			if ((i == (cycles - 1)) && (j == 7))
+				gpiod_set_value_cansleep(ddata->dld, 1);
+
+			if (i == 0 && j == 0)
+				gpiod_set_value_cansleep(ddata->dld, 0);
+
+			/* SGPMO */
+			gpiod_set_value_cansleep(ddata->dout, set & (1 << j));
+
+			/* SGPMI */
+			get <<= 1;
+			if (gpiod_get_value_cansleep(ddata->din))
+				get |= 1;
 		}
 
 		if (i < getbuf_len)
-			getbuf[i] = get;
-
-		ndelay(siox_bytegap_ns);
+			getbuf[(cycles - 1) - i] = get;
 	}
 
+	gpiod_set_value_cansleep(ddata->dclk, 1);
+	ndelay(siox_clkhigh_ns);
+	gpiod_set_value_cansleep(ddata->dclk, 0);
 	gpiod_set_value_cansleep(ddata->dld, 1);
-	ndelay(siox_loadhigh_ns);
-	gpiod_set_value_cansleep(ddata->dld, 0);
 
 	/*
 	 * Resetting dout isn't necessary protocol wise, but it makes the
@@ -80,6 +96,8 @@ static int siox_gpio_pushpull(struct siox_master *smaster,
 	 * the previous siox device.
 	 */
 	gpiod_set_value_cansleep(ddata->dout, 0);
+	if (ddata->dlb)
+		gpiod_set_value_cansleep(ddata->dlb, 0);
 
 	return 0;
 }
@@ -114,11 +132,15 @@ static int siox_gpio_probe(struct platform_device *pdev)
 		return dev_err_probe(dev, PTR_ERR(ddata->dclk),
 				     "Failed to get dclk GPIO\n");
 
-	ddata->dld = devm_gpiod_get(dev, "dld", GPIOD_OUT_LOW);
+	ddata->dld = devm_gpiod_get(dev, "dld", GPIOD_OUT_HIGH);
 	if (IS_ERR(ddata->dld))
 		return dev_err_probe(dev, PTR_ERR(ddata->dld),
 				     "Failed to get dld GPIO\n");
 
+	ddata->dlb = devm_gpiod_get(dev, "dlb", GPIOD_OUT_LOW);
+	if (IS_ERR(ddata->dlb))
+		ddata->dlb = NULL;
+
 	smaster->pushpull = siox_gpio_pushpull;
 	/* XXX: determine automatically like spi does */
 	smaster->busno = 0;
diff --git a/drivers/siox/siox-core.c b/drivers/siox/siox-core.c
index f98f5a27e659..e53c53b2b40c 100644
--- a/drivers/siox/siox-core.c
+++ b/drivers/siox/siox-core.c
@@ -37,6 +37,7 @@
 #include <trace/events/siox.h>
 
 static bool siox_is_registered;
+static u8 _lb_pattern = 0xAA; /* square wave */
 
 static void siox_master_lock(struct siox_master *smaster)
 {
@@ -94,11 +95,6 @@ static bool siox_device_type_error(struct siox_device *sdevice, u8 status_clean)
 	return false;
 }
 
-static bool siox_device_wdg_error(struct siox_device *sdevice, u8 status_clean)
-{
-	return (status_clean & SIOX_STATUS_WDG) == 0;
-}
-
 /*
  * If there is a type or counter error the device is called "unsynced".
  */
@@ -112,19 +108,6 @@ bool siox_device_synced(struct siox_device *sdevice)
 }
 EXPORT_SYMBOL_GPL(siox_device_synced);
 
-/*
- * A device is called "connected" if it is synced and the watchdog is not
- * asserted.
- */
-bool siox_device_connected(struct siox_device *sdevice)
-{
-	if (!siox_device_synced(sdevice))
-		return false;
-
-	return !siox_device_wdg_error(sdevice, sdevice->status_read_clean);
-}
-EXPORT_SYMBOL_GPL(siox_device_connected);
-
 static void siox_poll(struct siox_master *smaster)
 {
 	struct siox_device *sdevice;
@@ -153,38 +136,16 @@ static void siox_poll(struct siox_master *smaster)
 	list_for_each_entry(sdevice, &smaster->devices, node) {
 		struct siox_driver *sdriver =
 			to_siox_driver(sdevice->dev.driver);
-		sdevice->status_written = smaster->status;
-
-		i -= sdevice->inbytes;
-
-		/*
-		 * If the device or a previous one is unsynced, don't pet the
-		 * watchdog. This is done to ensure that the device is kept in
-		 * reset when something is wrong.
-		 */
-		if (!siox_device_synced(sdevice))
-			unsync_error = 1;
 
-		if (sdriver && !unsync_error)
-			sdriver->set_data(sdevice, sdevice->status_written,
-					  &smaster->buf[i + 1]);
-		else
-			/*
-			 * Don't trigger watchdog if there is no driver or a
-			 * sync problem
-			 */
-			sdevice->status_written &= ~SIOX_STATUS_WDG;
-
-		smaster->buf[i] = sdevice->status_written;
-
-		trace_siox_set_data(smaster, sdevice, devno, i);
+		if (sdriver)
+			sdriver->set_data(sdevice, 0, &smaster->buf[0]);
 
 		devno++;
 	}
 
 	smaster->pushpull(smaster, smaster->setbuf_len, smaster->buf,
 			  smaster->getbuf_len,
-			  smaster->buf + smaster->setbuf_len);
+			  smaster->buf + smaster->setbuf_len, _lb_pattern);
 
 	unsync_error = 0;
 
@@ -194,80 +155,9 @@ static void siox_poll(struct siox_master *smaster)
 	list_for_each_entry(sdevice, &smaster->devices, node) {
 		struct siox_driver *sdriver =
 			to_siox_driver(sdevice->dev.driver);
-		u8 status = smaster->buf[i + sdevice->outbytes - 1];
-		u8 status_clean;
-		u8 prev_status_clean = sdevice->status_read_clean;
-		bool synced = true;
-		bool connected = true;
-
-		if (!siox_device_synced(sdevice))
-			unsync_error = 1;
-
-		/*
-		 * If the watchdog bit wasn't toggled in this cycle, report the
-		 * watchdog as active to give a consistent view for drivers and
-		 * sysfs consumers.
-		 */
-		if (!sdriver || unsync_error)
-			status &= ~SIOX_STATUS_WDG;
-
-		status_clean =
-			siox_status_clean(status,
-					  sdevice->status_written_lastcycle);
-
-		/* Check counter and type bits */
-		if (siox_device_counter_error(sdevice, status_clean) ||
-		    siox_device_type_error(sdevice, status_clean)) {
-			bool prev_error;
-
-			synced = false;
-
-			/* only report a new error if the last cycle was ok */
-			prev_error =
-				siox_device_counter_error(sdevice,
-							  prev_status_clean) ||
-				siox_device_type_error(sdevice,
-						       prev_status_clean);
-
-			if (!prev_error) {
-				sdevice->status_errors++;
-				sysfs_notify_dirent(sdevice->status_errors_kn);
-			}
-		}
-
-		/* If the device is unsynced report the watchdog as active */
-		if (!synced) {
-			status &= ~SIOX_STATUS_WDG;
-			status_clean &= ~SIOX_STATUS_WDG;
-		}
-
-		if (siox_device_wdg_error(sdevice, status_clean))
-			connected = false;
-
-		/* The watchdog state changed just now */
-		if ((status_clean ^ prev_status_clean) & SIOX_STATUS_WDG) {
-			sysfs_notify_dirent(sdevice->watchdog_kn);
-
-			if (siox_device_wdg_error(sdevice, status_clean)) {
-				struct kernfs_node *wd_errs =
-					sdevice->watchdog_errors_kn;
-
-				sdevice->watchdog_errors++;
-				sysfs_notify_dirent(wd_errs);
-			}
-		}
-
-		if (connected != sdevice->connected)
-			sysfs_notify_dirent(sdevice->connected_kn);
-
-		sdevice->status_read_clean = status_clean;
-		sdevice->status_written_lastcycle = sdevice->status_written;
-		sdevice->connected = connected;
-
-		trace_siox_get_data(smaster, sdevice, devno, status_clean, i);
 
 		/* only give data read to driver if the device is connected */
-		if (sdriver && connected)
+		if (sdriver)
 			sdriver->get_data(sdevice, &smaster->buf[i]);
 
 		devno++;
@@ -479,6 +369,31 @@ static ssize_t watchdog_errors_show(struct device *dev,
 
 static DEVICE_ATTR_RO(watchdog_errors);
 
+static ssize_t lb_pattern_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "0x%02x\n", _lb_pattern);
+}
+
+static ssize_t lb_pattern_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct siox_master *smaster = to_siox_master(dev);
+	int ret;
+	u64 val;
+
+	ret = kstrtou64(buf, 0, &val);
+	if (ret < 0)
+		return ret;
+
+	_lb_pattern = (u8)val;
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(lb_pattern);
+
 static struct attribute *siox_device_attrs[] = {
 	&dev_attr_type.attr,
 	&dev_attr_inbytes.attr,
@@ -487,6 +402,7 @@ static struct attribute *siox_device_attrs[] = {
 	&dev_attr_connected.attr,
 	&dev_attr_watchdog.attr,
 	&dev_attr_watchdog_errors.attr,
+	&dev_attr_lb_pattern.attr,
 	NULL
 };
 ATTRIBUTE_GROUPS(siox_device);
@@ -603,10 +519,10 @@ static ssize_t device_add_store(struct device *dev,
 	if (ret != 3 && ret != 4)
 		return -EINVAL;
 
-	if (strcmp(type, "siox-12x8") || inbytes != 2 || outbytes != 4)
+	if (strcmp(type, "siox-128-128") || inbytes != 16 || outbytes != 16)
 		return -EINVAL;
 
-	siox_device_add(smaster, "siox-12x8", inbytes, outbytes, statustype);
+	siox_device_add(smaster, "siox-128-128", inbytes, outbytes, statustype);
 
 	return count;
 }
@@ -699,7 +615,8 @@ struct siox_master *siox_master_alloc(struct device *dev,
 	smaster->dev.bus = &siox_bus_type;
 	smaster->dev.type = &siox_master_type;
 	smaster->dev.parent = dev;
-	smaster->poll_interval = DIV_ROUND_UP(HZ, 40);
+	smaster->dev.of_node = dev->of_node;
+	smaster->poll_interval = nsecs_to_jiffies(10000000); /* default 10ms */
 
 	dev_set_drvdata(&smaster->dev, &smaster[1]);
 
@@ -810,6 +727,11 @@ int devm_siox_master_register(struct device *dev, struct siox_master *smaster)
 	if (ret)
 		return ret;
 
+	siox_device_add(smaster, "siox-128-128", 16, 16, 0);
+	ret = siox_start(smaster);
+	if (ret < 0)
+		dev_err(&smaster->dev, "siox_start failed\n");
+
 	return devm_add_action_or_reset(dev, devm_siox_master_unregister, smaster);
 }
 EXPORT_SYMBOL_GPL(devm_siox_master_register);
@@ -835,6 +757,7 @@ static struct siox_device *siox_device_add(struct siox_master *smaster,
 	sdevice->dev.parent = &smaster->dev;
 	sdevice->dev.bus = &siox_bus_type;
 	sdevice->dev.type = &siox_device_type;
+	sdevice->dev.of_node = smaster->dev.of_node;
 
 	siox_master_lock(smaster);
 
diff --git a/drivers/siox/siox.h b/drivers/siox/siox.h
index 513f2c8312f7..efe56072d428 100644
--- a/drivers/siox/siox.h
+++ b/drivers/siox/siox.h
@@ -12,7 +12,7 @@ struct siox_master {
 	int busno;
 	int (*pushpull)(struct siox_master *smaster,
 			size_t setbuf_len, const u8 setbuf[],
-			size_t getbuf_len, u8 getbuf[]);
+			size_t getbuf_len, u8 getbuf[], u8 lb_pattern);
 
 	/* might be initialized by the driver, if 0 it is set to HZ / 40 */
 	unsigned long poll_interval; /* in jiffies */
-- 
2.34.1

